
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>serving: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/featureform/serving/csv.go (0.0%)</option>
				
				<option value="file1">github.com/featureform/serving/dataset/dataset.go (56.2%)</option>
				
				<option value="file2">github.com/featureform/serving/metadata.go (0.0%)</option>
				
				<option value="file3">github.com/featureform/serving/metadata/client.go (0.0%)</option>
				
				<option value="file4">github.com/featureform/serving/metadata/client/client.go (0.0%)</option>
				
				<option value="file5">github.com/featureform/serving/metadata/dashboard/dashboard_metadata.go (0.0%)</option>
				
				<option value="file6">github.com/featureform/serving/metadata/metadata.go (6.6%)</option>
				
				<option value="file7">github.com/featureform/serving/metadata/proto/metadata.pb.go (6.6%)</option>
				
				<option value="file8">github.com/featureform/serving/metadata/proto/metadata_grpc.pb.go (0.0%)</option>
				
				<option value="file9">github.com/featureform/serving/metadata/search/search.go (16.7%)</option>
				
				<option value="file10">github.com/featureform/serving/metadata/server/server.go (0.0%)</option>
				
				<option value="file11">github.com/featureform/serving/metrics/interface.go (92.6%)</option>
				
				<option value="file12">github.com/featureform/serving/online.go (0.0%)</option>
				
				<option value="file13">github.com/featureform/serving/postgres/postgres.go (76.7%)</option>
				
				<option value="file14">github.com/featureform/serving/proto/serving.pb.go (10.1%)</option>
				
				<option value="file15">github.com/featureform/serving/proto/serving_grpc.pb.go (0.0%)</option>
				
				<option value="file16">github.com/featureform/serving/runner/copy.go (100.0%)</option>
				
				<option value="file17">github.com/featureform/serving/runner/library.go (100.0%)</option>
				
				<option value="file18">github.com/featureform/serving/serving.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "encoding/csv"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "strconv"

        "github.com/featureform/serving/dataset"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/service/s3"
        pb "github.com/featureform/serving/proto"
        "go.uber.org/zap"
)

type S3CSVProvider struct {
        Client *s3.S3
        Logger *zap.SugaredLogger
}

func (provider *S3CSVProvider) GetDatasetReader(key map[string]string) (dataset.Reader, error) <span class="cov0" title="0">{
        logger := provider.Logger.With("Key", key)
        logger.Debug("Finding S3 Dataset Reader")
        schemaJson, has := key["schema"]
        if !has </span><span class="cov0" title="0">{
                errMsg := "Schema not found in key"
                logger.Error(errMsg)
                return nil, fmt.Errorf(errMsg)
        }</span>
        <span class="cov0" title="0">var schema CSVSchema
        if err := json.Unmarshal([]byte(schemaJson), &amp;schema); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Invalid JSON schema", "Error", err)
                return nil, fmt.Errorf("Invalid Schema JSON %s: %s", schemaJson, err)
        }</span>
        <span class="cov0" title="0">bucket, has := key["bucket"]
        if !has </span><span class="cov0" title="0">{
                logger.Error("bucket not found in s3 key")
                return nil, fmt.Errorf("Invalid Key: missing bucket field")
        }</span>
        <span class="cov0" title="0">path, has := key["path"]
        if !has </span><span class="cov0" title="0">{
                logger.Error("path not found in s3 key")
                return nil, fmt.Errorf("Invalid Key: missing path field")
        }</span>

        <span class="cov0" title="0">out, err := provider.Client.GetObject(&amp;s3.GetObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(path),
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to get S3 object", "Err", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewCSVDataset(out.Body, schema)</span>
}

func (provider *S3CSVProvider) ToKey(bucket, path string, schema CSVSchema) map[string]string <span class="cov0" title="0">{
        key := make(map[string]string)
        logger := provider.Logger
        schemaJson, err := json.Marshal(schema)
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicw("Failed to marshal schema", "Error", err)
        }</span>
        <span class="cov0" title="0">key["schema"] = string(schemaJson)
        key["bucket"] = bucket
        key["path"] = path
        logger.Debugw("Generated key from schema", "Key", key, "Schema", schema)
        return key</span>
}

type LocalCSVProvider struct {
        Logger *zap.SugaredLogger
}

func (provider *LocalCSVProvider) GetDatasetReader(key map[string]string) (dataset.Reader, error) <span class="cov0" title="0">{
        logger := provider.Logger.With("Key", key)
        logger.Debug("Finding Local CSV Dataset Reader")
        schemaJson, has := key["schema"]
        if !has </span><span class="cov0" title="0">{
                errMsg := "Schema not found in key"
                logger.Error(errMsg)
                return nil, fmt.Errorf(errMsg)
        }</span>
        <span class="cov0" title="0">var schema CSVSchema
        if err := json.Unmarshal([]byte(schemaJson), &amp;schema); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Invalid JSON schema", "Error", err)
                return nil, fmt.Errorf("Invalid Schema JSON %s: %s", schemaJson, err)
        }</span>
        <span class="cov0" title="0">path, has := key["path"]
        if !has </span><span class="cov0" title="0">{
                logger.Error("Path not found in schema")
                return nil, fmt.Errorf("Path not found in schema")
        }</span>
        <span class="cov0" title="0">f, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to open file", "Error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewCSVDataset(f, schema)</span>
}

func (provider *LocalCSVProvider) ToKey(path string, schema CSVSchema) map[string]string <span class="cov0" title="0">{
        key := make(map[string]string)
        logger := provider.Logger
        schemaJson, err := json.Marshal(schema)
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicw("Failed to marshal schema", "Error", err)
        }</span>
        <span class="cov0" title="0">key["schema"] = string(schemaJson)
        key["path"] = path
        logger.Debugw("Generated key from schema", "Key", key, "Schema", schema)
        return key</span>
}

type CSVDataset struct {
        reader     *csv.Reader
        mapping    *csvMapping
        scannedRow *dataset.Row
        curErr     error
}

type CSVSchema struct {
        HasHeader bool
        Header    []string
        Features  []string
        Label     string
        Types     map[string]dataset.Type
}

func (schema CSVSchema) toMapping() (*csvMapping, error) <span class="cov0" title="0">{
        reverseIdx := make(map[string]int)
        for i, header := range schema.Header </span><span class="cov0" title="0">{
                reverseIdx[header] = i
        }</span>
        <span class="cov0" title="0">labelIdx, has := reverseIdx[schema.Label]
        if !has </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Label not in header: %v", schema)
        }</span>
        <span class="cov0" title="0">labelType, has := schema.Types[schema.Label]
        if !has </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Label type not found: %v", schema)
        }</span>
        <span class="cov0" title="0">labelCastFn, err := getCsvCastFn(labelType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">featureIdxs := make([]int, len(schema.Features))
        featureCastFns := make([]csvCastFn, len(schema.Features))
        for i, feature := range schema.Features </span><span class="cov0" title="0">{
                idx, has := reverseIdx[feature]
                if !has </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Not all fields are in header: %v", schema)
                }</span>
                <span class="cov0" title="0">featureType, has := schema.Types[feature]
                if !has </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Feature %s type not found: %v", feature, schema)
                }</span>
                <span class="cov0" title="0">castFn, err := getCsvCastFn(featureType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">featureIdxs[i] = idx
                featureCastFns[i] = castFn</span>
        }

        <span class="cov0" title="0">return &amp;csvMapping{
                LabelIdx:       labelIdx,
                FeatureIdxs:    featureIdxs,
                LabelCastFn:    labelCastFn,
                FeatureCastFns: featureCastFns,
        }, nil</span>
}

type csvCastFn func(string) (*pb.Value, error)

func getCsvCastFn(t dataset.Type) (csvCastFn, error) <span class="cov0" title="0">{
        switch t </span>{
        case dataset.String:<span class="cov0" title="0">
                return func(str string) (*pb.Value, error) </span><span class="cov0" title="0">{
                        return dataset.WrapStr(str), nil
                }</span>, nil
        case dataset.Float:<span class="cov0" title="0">
                return func(str string) (*pb.Value, error) </span><span class="cov0" title="0">{
                        flt, err := strconv.ParseFloat(str, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return dataset.WrapFloat(float32(flt)), nil</span>
                }, nil
        case dataset.Int:<span class="cov0" title="0">
                return func(str string) (*pb.Value, error) </span><span class="cov0" title="0">{
                        num, err := strconv.ParseInt(str, 10, 32)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return dataset.WrapInt(int32(num)), nil</span>
                }, nil
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("Unknown type")</span>
}

type csvMapping struct {
        LabelIdx       int
        FeatureIdxs    []int
        FeatureCastFns []csvCastFn
        LabelCastFn    csvCastFn
}

func NewCSVDataset(f io.Reader, schema CSVSchema) (*CSVDataset, error) <span class="cov0" title="0">{
        reader := csv.NewReader(f)

        if schema.HasHeader </span><span class="cov0" title="0">{
                header, err := reader.Read()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">schema.Header = header</span>
        }

        <span class="cov0" title="0">mapping, err := schema.toMapping()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;CSVDataset{
                reader:  reader,
                mapping: mapping,
        }, nil</span>
}

func (ds *CSVDataset) Scan() bool <span class="cov0" title="0">{
        row, err := ds.reader.Read()
        if err != nil </span><span class="cov0" title="0">{
                if err != io.EOF </span><span class="cov0" title="0">{
                        ds.curErr = err
                }</span>
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov0" title="0">trainRow := dataset.NewRow()
        mapping := ds.mapping
        for i, csvIdx := range mapping.FeatureIdxs </span><span class="cov0" title="0">{
                castFn := mapping.FeatureCastFns[i]
                val := row[csvIdx]
                casted, err := castFn(val)
                if err != nil </span><span class="cov0" title="0">{
                        ds.curErr = err
                        return false
                }</span>
                <span class="cov0" title="0">addErr := trainRow.AddFeature(casted)
                if addErr != nil </span><span class="cov0" title="0">{
                        ds.curErr = addErr
                        return false
                }</span>
        }
        <span class="cov0" title="0">label, err := mapping.LabelCastFn(row[mapping.LabelIdx])
        if err != nil </span><span class="cov0" title="0">{
                ds.curErr = err
                return false
        }</span>
        <span class="cov0" title="0">setErr := trainRow.SetLabel(label)
        if setErr != nil </span><span class="cov0" title="0">{
                ds.curErr = setErr
                return false
        }</span>
        <span class="cov0" title="0">ds.scannedRow = trainRow
        return true</span>
}

func (ds *CSVDataset) Row() *dataset.Row <span class="cov0" title="0">{
        return ds.scannedRow
}</span>

func (ds *CSVDataset) Err() error <span class="cov0" title="0">{
        return ds.curErr
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package dataset

import (
        "fmt"

        pb "github.com/featureform/serving/proto"
)

type OfflineProvider interface {
        GetDatasetReader(key map[string]string) (Reader, error)
}

type OnlineProvider interface {
        GetFeatureLookup(key map[string]string) (Lookup, error)
}

type Reader interface {
        Scan() bool
        Row() *Row
        Err() error
}

type Lookup interface {
        Get(entity string) (*Feature, error)
}

type Feature struct {
        serialized *pb.Value
}

func NewFeature(val interface{}) (*Feature, error) <span class="cov0" title="0">{
        serial, err := WrapValue(val)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Feature{serial}, nil</span>
}

func (f *Feature) Serialized() *pb.Value <span class="cov0" title="0">{
        return f.serialized
}</span>

type Row struct {
        serialized *pb.TrainingDataRow
}

func NewRow() *Row <span class="cov8" title="1">{
        return &amp;Row{
                serialized: &amp;pb.TrainingDataRow{},
        }
}</span>

func (row *Row) Serialized() *pb.TrainingDataRow <span class="cov8" title="1">{
        return row.serialized
}</span>

func (row *Row) SetLabel(label interface{}) error <span class="cov8" title="1">{
        value, err := WrapValue(label)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">row.serialized.Label = value
        return nil</span>
}

func (row *Row) AddFeature(feature interface{}) error <span class="cov8" title="1">{
        value, err := WrapValue(feature)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">row.serialized.Features = append(row.serialized.Features, value)
        return nil</span>
}

type InvalidValue struct {
        Value interface{}
}

func (err InvalidValue) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Invalid Value Type: %T", err.Value)
}</span>

func WrapValue(value interface{}) (proto *pb.Value, err error) <span class="cov8" title="1">{
        switch typed := value.(type) </span>{
        case string:<span class="cov8" title="1">
                proto = WrapStr(typed)</span>
        case float32:<span class="cov0" title="0">
                proto = WrapFloat(typed)</span>
        case float64:<span class="cov8" title="1">
                proto = WrapDouble(typed)</span>
        case int32:<span class="cov0" title="0">
                proto = WrapInt(typed)</span>
        case int64:<span class="cov8" title="1">
                proto = WrapInt64(typed)</span>
        case *pb.Value:<span class="cov0" title="0">
                proto = typed</span>
        default:<span class="cov0" title="0">
                err = InvalidValue{value}</span>
        }
        <span class="cov8" title="1">return</span>
}

func WrapFloat(val float32) *pb.Value <span class="cov0" title="0">{
        return &amp;pb.Value{
                Value: &amp;pb.Value_FloatValue{val},
        }
}</span>

func WrapDouble(val float64) *pb.Value <span class="cov8" title="1">{
        return &amp;pb.Value{
                Value: &amp;pb.Value_DoubleValue{val},
        }
}</span>

func WrapStr(val string) *pb.Value <span class="cov8" title="1">{
        return &amp;pb.Value{
                Value: &amp;pb.Value_StrValue{val},
        }
}</span>

func WrapInt(val int32) *pb.Value <span class="cov0" title="0">{
        return &amp;pb.Value{
                Value: &amp;pb.Value_IntValue{val},
        }
}</span>

func WrapInt64(val int64) *pb.Value <span class="cov8" title="1">{
        return &amp;pb.Value{
                Value: &amp;pb.Value_Int64Value{val},
        }
}</span>

type Type int

const (
        String Type = iota
        Float
        Int
)
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "sync"

        "go.uber.org/zap"
)

type MetadataProvider interface {
        TrainingSetMetadata(name, version string) (TrainingSetEntry, error)
        SetTrainingSetMetadata(name, version string, entry TrainingSetEntry) error
        FeatureMetadata(name, version string) (FeatureEntry, error)
        SetFeatureMetadata(name, version string, entry FeatureEntry) error
}

type FeatureEntry struct {
        StorageId string
        Entity    string
        Key       map[string]string
}

type TrainingSetEntry struct {
        StorageId string
        Key       map[string]string
}

func (entry TrainingSetEntry) Valid() error <span class="cov0" title="0">{
        if entry.StorageId == "" </span><span class="cov0" title="0">{
                return &amp;MetadataError{"StorageId must be set in metadata."}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type TrainingSetId struct {
        Name, Version string
}

func (id TrainingSetId) Valid() error <span class="cov0" title="0">{
        if id.Name == "" </span><span class="cov0" title="0">{
                return &amp;MetadataError{"Dataset name must be provided."}
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FeatureId struct {
        Name, Version string
}

type LocalMemoryMetadata struct {
        Logger         *zap.SugaredLogger
        trainingSets   map[TrainingSetId]TrainingSetEntry
        trainingSetMtx *sync.RWMutex
        features       map[FeatureId]FeatureEntry
        featureMtx     *sync.RWMutex
}

func NewLocalMemoryMetadata(logger *zap.SugaredLogger) (MetadataProvider, error) <span class="cov0" title="0">{
        logger.Debug("Creating new local memory metadata")
        return &amp;LocalMemoryMetadata{
                Logger:         logger,
                trainingSets:   make(map[TrainingSetId]TrainingSetEntry),
                trainingSetMtx: &amp;sync.RWMutex{},
                features:       make(map[FeatureId]FeatureEntry),
                featureMtx:     &amp;sync.RWMutex{},
        }, nil
}</span>

type MetadataError struct {
        Msg string
}

func (err *MetadataError) Error() string <span class="cov0" title="0">{
        return err.Msg
}</span>

func (provider *LocalMemoryMetadata) SetTrainingSetMetadata(name, version string, entry TrainingSetEntry) error <span class="cov0" title="0">{
        provider.trainingSetMtx.Lock()
        defer provider.trainingSetMtx.Unlock()
        logger := provider.Logger.With("Name", name, "Version", version, "Entry", entry)
        logger.Debug("Setting training metadata")
        if err := entry.Valid(); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Invalid Metadata Entry", "Error", err)
                return err
        }</span>
        <span class="cov0" title="0">provider.trainingSets[TrainingSetId{name, version}] = entry
        return nil</span>
}

func (provider *LocalMemoryMetadata) TrainingSetMetadata(name, version string) (TrainingSetEntry, error) <span class="cov0" title="0">{
        provider.trainingSetMtx.RLock()
        defer provider.trainingSetMtx.RUnlock()
        logger := provider.Logger.With("Name", name, "Version", version, "Type", "Training set")
        logger.Debug("Retrieving training set metadata")
        entry, has := provider.trainingSets[TrainingSetId{name, version}]
        if !has </span><span class="cov0" title="0">{
                logger.Error("Training set metadata not found")
                return entry, &amp;MetadataError{"Training set not found."}
        }</span>
        <span class="cov0" title="0">return entry, nil</span>
}

func (provider *LocalMemoryMetadata) SetFeatureMetadata(name, version string, entry FeatureEntry) error <span class="cov0" title="0">{
        provider.featureMtx.Lock()
        defer provider.featureMtx.Unlock()
        logger := provider.Logger.With("Name", name, "Version", version, "Entry", entry)
        logger.Debug("Setting feature metadata")
        provider.features[FeatureId{name, version}] = entry
        return nil
}</span>

func (provider *LocalMemoryMetadata) FeatureMetadata(name, version string) (FeatureEntry, error) <span class="cov0" title="0">{
        provider.featureMtx.RLock()
        defer provider.featureMtx.RUnlock()
        logger := provider.Logger.With("Name", name, "Version", version, "Type", "Feature")
        logger.Debug("Retrieving Metadata")
        entry, has := provider.features[FeatureId{name, version}]
        if !has </span><span class="cov0" title="0">{
                logger.Error("Feature not found")
                return entry, &amp;MetadataError{"Feature not found."}
        }</span>
        <span class="cov0" title="0">return entry, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package metadata

import (
        "context"
        "fmt"
        "io"
        "time"

        pb "github.com/featureform/serving/metadata/proto"
        "go.uber.org/zap"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
        "google.golang.org/protobuf/encoding/protojson"
        "google.golang.org/protobuf/proto"
)

type NameVariant struct {
        Name    string
        Variant string
}

func (variant NameVariant) Serialize() *pb.NameVariant <span class="cov0" title="0">{
        return &amp;pb.NameVariant{
                Name:    variant.Name,
                Variant: variant.Variant,
        }
}</span>

func parseNameVariant(serialized *pb.NameVariant) NameVariant <span class="cov0" title="0">{
        return NameVariant{
                Name:    serialized.Name,
                Variant: serialized.Variant,
        }
}</span>

type NameVariants []NameVariant

func (variants NameVariants) Serialize() []*pb.NameVariant <span class="cov0" title="0">{
        serialized := make([]*pb.NameVariant, len(variants))
        for i, variant := range variants </span><span class="cov0" title="0">{
                serialized[i] = variant.Serialize()
        }</span>
        <span class="cov0" title="0">return serialized</span>
}

func parseNameVariants(protos []*pb.NameVariant) NameVariants <span class="cov0" title="0">{
        parsed := make([]NameVariant, len(protos))
        for i, serialized := range protos </span><span class="cov0" title="0">{
                parsed[i] = parseNameVariant(serialized)
        }</span>
        <span class="cov0" title="0">return parsed</span>
}

type Client struct {
        Logger   *zap.SugaredLogger
        conn     *grpc.ClientConn
        grpcConn pb.MetadataClient
}

type ResourceDef interface {
        ResourceType() ResourceType
}

func (client *Client) CreateAll(ctx context.Context, defs []ResourceDef) error <span class="cov0" title="0">{
        for _, def := range defs </span><span class="cov0" title="0">{
                if err := client.Create(ctx, def); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (client *Client) Create(ctx context.Context, def ResourceDef) error <span class="cov0" title="0">{
        switch casted := def.(type) </span>{
        case FeatureDef:<span class="cov0" title="0">
                return client.CreateFeatureVariant(ctx, casted)</span>
        case LabelDef:<span class="cov0" title="0">
                return client.CreateLabelVariant(ctx, casted)</span>
        case TrainingSetDef:<span class="cov0" title="0">
                return client.CreateTrainingSetVariant(ctx, casted)</span>
        case SourceDef:<span class="cov0" title="0">
                return client.CreateSourceVariant(ctx, casted)</span>
        case UserDef:<span class="cov0" title="0">
                return client.CreateUser(ctx, casted)</span>
        case ProviderDef:<span class="cov0" title="0">
                return client.CreateProvider(ctx, casted)</span>
        case EntityDef:<span class="cov0" title="0">
                return client.CreateEntity(ctx, casted)</span>
        case ModelDef:<span class="cov0" title="0">
                return client.CreateModel(ctx, casted)</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("%T not implemented in Created.", casted))</span>
        }
}

func (client *Client) ListFeatures(ctx context.Context) ([]*Feature, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.ListFeatures(ctx, &amp;pb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client.parseFeatureStream(stream)</span>
}

func (client *Client) GetFeature(ctx context.Context, feature string) (*Feature, error) <span class="cov0" title="0">{
        featureList, err := client.GetFeatures(ctx, []string{feature})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return featureList[0], nil</span>
}

func (client *Client) GetFeatures(ctx context.Context, features []string) ([]*Feature, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetFeatures(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for _, feature := range features </span><span class="cov0" title="0">{
                        stream.Send(&amp;pb.Name{Name: feature})
                }</span>
                <span class="cov0" title="0">err := stream.CloseSend()
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Errorw("Failed to close send", "Err", err)
                }</span>
        }()
        <span class="cov0" title="0">return client.parseFeatureStream(stream)</span>
}

func (client *Client) GetFeatureVariants(ctx context.Context, ids []NameVariant) ([]*FeatureVariant, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetFeatureVariants(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for _, id := range ids </span><span class="cov0" title="0">{
                        stream.Send(&amp;pb.NameVariant{Name: id.Name, Variant: id.Variant})
                }</span>
                <span class="cov0" title="0">err := stream.CloseSend()
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Errorw("Failed to close send", "Err", err)
                }</span>
        }()
        <span class="cov0" title="0">return client.parseFeatureVariantStream(stream)</span>
}

func (client *Client) GetFeatureVariant(ctx context.Context, id NameVariant) (*FeatureVariant, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetFeatureVariants(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go stream.Send(id.Serialize())
        variants, err := client.parseFeatureVariantStream(stream)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return variants[0], nil</span>
}

type FeatureDef struct {
        Name        string
        Variant     string
        Source      NameVariant
        Type        string
        Entity      string
        Owner       string
        Description string
        Provider    string
}

func (def FeatureDef) ResourceType() ResourceType <span class="cov0" title="0">{
        return FEATURE_VARIANT
}</span>

func (client *Client) CreateFeatureVariant(ctx context.Context, def FeatureDef) error <span class="cov0" title="0">{
        serialized := &amp;pb.FeatureVariant{
                Name:        def.Name,
                Variant:     def.Variant,
                Source:      def.Source.Serialize(),
                Type:        def.Type,
                Entity:      def.Entity,
                Owner:       def.Owner,
                Description: def.Description,
                Provider:    def.Provider,
        }
        _, err := client.grpcConn.CreateFeatureVariant(ctx, serialized)
        return err
}</span>

type featureStream interface {
        Recv() (*pb.Feature, error)
}

func (client *Client) parseFeatureStream(stream featureStream) ([]*Feature, error) <span class="cov0" title="0">{
        features := make([]*Feature, 0)
        for </span><span class="cov0" title="0">{
                serial, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">features = append(features, wrapProtoFeature(serial))</span>
        }
        <span class="cov0" title="0">return features, nil</span>
}

type featureVariantStream interface {
        Recv() (*pb.FeatureVariant, error)
}

func (client *Client) parseFeatureVariantStream(stream featureVariantStream) ([]*FeatureVariant, error) <span class="cov0" title="0">{
        features := make([]*FeatureVariant, 0)
        for </span><span class="cov0" title="0">{
                serial, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">features = append(features, wrapProtoFeatureVariant(serial))</span>
        }
        <span class="cov0" title="0">return features, nil</span>
}

func (client *Client) ListLabels(ctx context.Context) ([]*Label, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.ListLabels(ctx, &amp;pb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client.parseLabelStream(stream)</span>
}

func (client *Client) GetLabel(ctx context.Context, label string) (*Label, error) <span class="cov0" title="0">{
        labelList, err := client.GetLabels(ctx, []string{label})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return labelList[0], nil</span>
}

func (client *Client) GetLabels(ctx context.Context, labels []string) ([]*Label, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetLabels(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for _, label := range labels </span><span class="cov0" title="0">{
                        stream.Send(&amp;pb.Name{Name: label})
                }</span>
                <span class="cov0" title="0">err := stream.CloseSend()
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Errorw("Failed to close send", "Err", err)
                }</span>
        }()
        <span class="cov0" title="0">return client.parseLabelStream(stream)</span>
}

type LabelDef struct {
        Name        string
        Variant     string
        Description string
        Type        string
        Source      NameVariant
        Entity      string
        Owner       string
        Provider    string
}

func (def LabelDef) ResourceType() ResourceType <span class="cov0" title="0">{
        return LABEL_VARIANT
}</span>

func (client *Client) CreateLabelVariant(ctx context.Context, def LabelDef) error <span class="cov0" title="0">{
        serialized := &amp;pb.LabelVariant{
                Name:        def.Name,
                Variant:     def.Variant,
                Description: def.Description,
                Type:        def.Type,
                Source:      def.Source.Serialize(),
                Entity:      def.Entity,
                Owner:       def.Owner,
                Provider:    def.Provider,
        }
        _, err := client.grpcConn.CreateLabelVariant(ctx, serialized)
        return err
}</span>

func (client *Client) GetLabelVariants(ctx context.Context, ids []NameVariant) ([]*LabelVariant, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetLabelVariants(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for _, id := range ids </span><span class="cov0" title="0">{
                        stream.Send(&amp;pb.NameVariant{Name: id.Name, Variant: id.Variant})
                }</span>
                <span class="cov0" title="0">err := stream.CloseSend()
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Errorw("Failed to close send", "Err", err)
                }</span>
        }()
        <span class="cov0" title="0">return client.parseLabelVariantStream(stream)</span>
}

func (client *Client) GetLabelVariant(ctx context.Context, id NameVariant) (*LabelVariant, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetLabelVariants(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go stream.Send(id.Serialize())
        variants, err := client.parseLabelVariantStream(stream)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return variants[0], nil</span>
}

type labelStream interface {
        Recv() (*pb.Label, error)
}

func (client *Client) parseLabelStream(stream labelStream) ([]*Label, error) <span class="cov0" title="0">{
        labels := make([]*Label, 0)
        for </span><span class="cov0" title="0">{
                serial, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">labels = append(labels, wrapProtoLabel(serial))</span>
        }
        <span class="cov0" title="0">return labels, nil</span>
}

type labelVariantStream interface {
        Recv() (*pb.LabelVariant, error)
}

func (client *Client) parseLabelVariantStream(stream labelVariantStream) ([]*LabelVariant, error) <span class="cov0" title="0">{
        features := make([]*LabelVariant, 0)
        for </span><span class="cov0" title="0">{
                serial, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">features = append(features, wrapProtoLabelVariant(serial))</span>
        }
        <span class="cov0" title="0">return features, nil</span>
}

func (client *Client) ListTrainingSets(ctx context.Context) ([]*TrainingSet, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.ListTrainingSets(ctx, &amp;pb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client.parseTrainingSetStream(stream)</span>
}

func (client *Client) GetTrainingSet(ctx context.Context, trainingSet string) (*TrainingSet, error) <span class="cov0" title="0">{
        trainingSetList, err := client.GetTrainingSets(ctx, []string{trainingSet})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return trainingSetList[0], nil</span>
}

func (client *Client) GetTrainingSets(ctx context.Context, trainingSets []string) ([]*TrainingSet, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetTrainingSets(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for _, trainingSet := range trainingSets </span><span class="cov0" title="0">{
                        stream.Send(&amp;pb.Name{Name: trainingSet})
                }</span>
                <span class="cov0" title="0">err := stream.CloseSend()
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Errorw("Failed to close send", "Err", err)
                }</span>
        }()
        <span class="cov0" title="0">return client.parseTrainingSetStream(stream)</span>
}

type TrainingSetDef struct {
        Name        string
        Variant     string
        Description string
        Owner       string
        Provider    string
        Label       NameVariant
        Features    NameVariants
}

func (def TrainingSetDef) ResourceType() ResourceType <span class="cov0" title="0">{
        return TRAINING_SET_VARIANT
}</span>

func (client *Client) CreateTrainingSetVariant(ctx context.Context, def TrainingSetDef) error <span class="cov0" title="0">{
        serialized := &amp;pb.TrainingSetVariant{
                Name:        def.Name,
                Variant:     def.Variant,
                Description: def.Description,
                Owner:       def.Owner,
                Provider:    def.Provider,
                Label:       def.Label.Serialize(),
                Features:    def.Features.Serialize(),
        }
        _, err := client.grpcConn.CreateTrainingSetVariant(ctx, serialized)
        return err
}</span>

func (client *Client) GetTrainingSetVariant(ctx context.Context, id NameVariant) (*TrainingSetVariant, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetTrainingSetVariants(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go stream.Send(id.Serialize())
        variants, err := client.parseTrainingSetVariantStream(stream)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return variants[0], nil</span>
}

func (client *Client) GetTrainingSetVariants(ctx context.Context, ids []NameVariant) ([]*TrainingSetVariant, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetTrainingSetVariants(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for _, id := range ids </span><span class="cov0" title="0">{
                        stream.Send(&amp;pb.NameVariant{Name: id.Name, Variant: id.Variant})
                }</span>
                <span class="cov0" title="0">err := stream.CloseSend()
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Errorw("Failed to close send", "Err", err)
                }</span>
        }()
        <span class="cov0" title="0">return client.parseTrainingSetVariantStream(stream)</span>
}

type trainingSetStream interface {
        Recv() (*pb.TrainingSet, error)
}

func (client *Client) parseTrainingSetStream(stream trainingSetStream) ([]*TrainingSet, error) <span class="cov0" title="0">{
        trainingSets := make([]*TrainingSet, 0)
        for </span><span class="cov0" title="0">{
                serial, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">trainingSets = append(trainingSets, wrapProtoTrainingSet(serial))</span>
        }
        <span class="cov0" title="0">return trainingSets, nil</span>
}

type trainingSetVariantStream interface {
        Recv() (*pb.TrainingSetVariant, error)
}

func (client *Client) parseTrainingSetVariantStream(stream trainingSetVariantStream) ([]*TrainingSetVariant, error) <span class="cov0" title="0">{
        features := make([]*TrainingSetVariant, 0)
        for </span><span class="cov0" title="0">{
                serial, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">features = append(features, wrapProtoTrainingSetVariant(serial))</span>
        }
        <span class="cov0" title="0">return features, nil</span>
}

func (client *Client) ListSources(ctx context.Context) ([]*Source, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.ListSources(ctx, &amp;pb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client.parseSourceStream(stream)</span>
}

func (client *Client) GetSource(ctx context.Context, source string) (*Source, error) <span class="cov0" title="0">{
        sourceList, err := client.GetSources(ctx, []string{source})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return sourceList[0], nil</span>
}

func (client *Client) GetSources(ctx context.Context, sources []string) ([]*Source, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetSources(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for _, source := range sources </span><span class="cov0" title="0">{
                        stream.Send(&amp;pb.Name{Name: source})
                }</span>
                <span class="cov0" title="0">err := stream.CloseSend()
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Errorw("Failed to close send", "Err", err)
                }</span>
        }()
        <span class="cov0" title="0">return client.parseSourceStream(stream)</span>
}

type SourceDef struct {
        Name        string
        Variant     string
        Description string
        Type        string
        Owner       string
        Provider    string
}

func (def SourceDef) ResourceType() ResourceType <span class="cov0" title="0">{
        return SOURCE_VARIANT
}</span>

func (client *Client) CreateSourceVariant(ctx context.Context, def SourceDef) error <span class="cov0" title="0">{
        serialized := &amp;pb.SourceVariant{
                Name:        def.Name,
                Variant:     def.Variant,
                Description: def.Description,
                Type:        def.Type,
                Owner:       def.Owner,
                Provider:    def.Provider,
        }
        _, err := client.grpcConn.CreateSourceVariant(ctx, serialized)
        return err
}</span>

func (client *Client) GetSourceVariants(ctx context.Context, ids []NameVariant) ([]*SourceVariant, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetSourceVariants(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for _, id := range ids </span><span class="cov0" title="0">{
                        stream.Send(&amp;pb.NameVariant{Name: id.Name, Variant: id.Variant})
                }</span>
                <span class="cov0" title="0">err := stream.CloseSend()
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Errorw("Failed to close send", "Err", err)
                }</span>
        }()
        <span class="cov0" title="0">return client.parseSourceVariantStream(stream)</span>
}

func (client *Client) GetSourceVariant(ctx context.Context, id NameVariant) (*SourceVariant, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetSourceVariants(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go stream.Send(id.Serialize())
        variants, err := client.parseSourceVariantStream(stream)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return variants[0], nil</span>
}

type sourceStream interface {
        Recv() (*pb.Source, error)
}

func (client *Client) parseSourceStream(stream sourceStream) ([]*Source, error) <span class="cov0" title="0">{
        sources := make([]*Source, 0)
        for </span><span class="cov0" title="0">{
                serial, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">sources = append(sources, wrapProtoSource(serial))</span>
        }
        <span class="cov0" title="0">return sources, nil</span>
}

type sourceVariantStream interface {
        Recv() (*pb.SourceVariant, error)
}

func (client *Client) parseSourceVariantStream(stream sourceVariantStream) ([]*SourceVariant, error) <span class="cov0" title="0">{
        features := make([]*SourceVariant, 0)
        for </span><span class="cov0" title="0">{
                serial, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">features = append(features, wrapProtoSourceVariant(serial))</span>
        }
        <span class="cov0" title="0">return features, nil</span>
}

func (client *Client) ListUsers(ctx context.Context) ([]*User, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.ListUsers(ctx, &amp;pb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client.parseUserStream(stream)</span>
}

func (client *Client) GetUser(ctx context.Context, user string) (*User, error) <span class="cov0" title="0">{
        userList, err := client.GetUsers(ctx, []string{user})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return userList[0], nil</span>
}

func (client *Client) GetUsers(ctx context.Context, users []string) ([]*User, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetUsers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for _, user := range users </span><span class="cov0" title="0">{
                        stream.Send(&amp;pb.Name{Name: user})
                }</span>
                <span class="cov0" title="0">err := stream.CloseSend()
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Errorw("Failed to close send", "Err", err)
                }</span>
        }()
        <span class="cov0" title="0">return client.parseUserStream(stream)</span>
}

type UserDef struct {
        Name string
}

func (def UserDef) ResourceType() ResourceType <span class="cov0" title="0">{
        return USER
}</span>

func (client *Client) CreateUser(ctx context.Context, def UserDef) error <span class="cov0" title="0">{
        serialized := &amp;pb.User{
                Name: def.Name,
        }
        _, err := client.grpcConn.CreateUser(ctx, serialized)
        return err
}</span>

type userStream interface {
        Recv() (*pb.User, error)
}

func (client *Client) parseUserStream(stream userStream) ([]*User, error) <span class="cov0" title="0">{
        users := make([]*User, 0)
        for </span><span class="cov0" title="0">{
                serial, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">users = append(users, wrapProtoUser(serial))</span>
        }
        <span class="cov0" title="0">return users, nil</span>
}

func (client *Client) ListProviders(ctx context.Context) ([]*Provider, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.ListProviders(ctx, &amp;pb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client.parseProviderStream(stream)</span>
}

func (client *Client) GetProvider(ctx context.Context, provider string) (*Provider, error) <span class="cov0" title="0">{
        providerList, err := client.GetProviders(ctx, []string{provider})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return providerList[0], nil</span>
}

func (client *Client) GetProviders(ctx context.Context, providers []string) ([]*Provider, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetProviders(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for _, provider := range providers </span><span class="cov0" title="0">{
                        stream.Send(&amp;pb.Name{Name: provider})
                }</span>
                <span class="cov0" title="0">err := stream.CloseSend()
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Errorw("Failed to close send", "Err", err)
                }</span>
        }()
        <span class="cov0" title="0">return client.parseProviderStream(stream)</span>
}

type ProviderDef struct {
        Name        string
        Description string
        Type        string
        Software    string
        Team        string
}

func (def ProviderDef) ResourceType() ResourceType <span class="cov0" title="0">{
        return PROVIDER
}</span>

func (client *Client) CreateProvider(ctx context.Context, def ProviderDef) error <span class="cov0" title="0">{
        serialized := &amp;pb.Provider{
                Name:        def.Name,
                Description: def.Description,
                Type:        def.Type,
                Software:    def.Software,
                Team:        def.Team,
        }
        _, err := client.grpcConn.CreateProvider(ctx, serialized)
        return err
}</span>

type providerStream interface {
        Recv() (*pb.Provider, error)
}

func (client *Client) parseProviderStream(stream providerStream) ([]*Provider, error) <span class="cov0" title="0">{
        providers := make([]*Provider, 0)
        for </span><span class="cov0" title="0">{
                serial, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">providers = append(providers, wrapProtoProvider(serial))</span>
        }
        <span class="cov0" title="0">return providers, nil</span>
}

func (client *Client) ListEntities(ctx context.Context) ([]*Entity, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.ListEntities(ctx, &amp;pb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client.parseEntityStream(stream)</span>
}

func (client *Client) GetEntity(ctx context.Context, entity string) (*Entity, error) <span class="cov0" title="0">{
        entityList, err := client.GetEntities(ctx, []string{entity})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return entityList[0], nil</span>
}

func (client *Client) GetEntities(ctx context.Context, entities []string) ([]*Entity, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetEntities(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for _, entity := range entities </span><span class="cov0" title="0">{
                        stream.Send(&amp;pb.Name{Name: entity})
                }</span>
                <span class="cov0" title="0">err := stream.CloseSend()
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Errorw("Failed to close send", "Err", err)
                }</span>
        }()
        <span class="cov0" title="0">return client.parseEntityStream(stream)</span>
}

type EntityDef struct {
        Name        string
        Description string
}

func (def EntityDef) ResourceType() ResourceType <span class="cov0" title="0">{
        return ENTITY
}</span>

func (client *Client) CreateEntity(ctx context.Context, def EntityDef) error <span class="cov0" title="0">{
        serialized := &amp;pb.Entity{
                Name:        def.Name,
                Description: def.Description,
        }
        _, err := client.grpcConn.CreateEntity(ctx, serialized)
        return err
}</span>

type entityStream interface {
        Recv() (*pb.Entity, error)
}

func (client *Client) parseEntityStream(stream entityStream) ([]*Entity, error) <span class="cov0" title="0">{
        entities := make([]*Entity, 0)
        for </span><span class="cov0" title="0">{
                serial, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">entities = append(entities, wrapProtoEntity(serial))</span>
        }
        <span class="cov0" title="0">return entities, nil</span>
}

func (client *Client) ListModels(ctx context.Context) ([]*Model, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.ListModels(ctx, &amp;pb.Empty{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return client.parseModelStream(stream)</span>
}

func (client *Client) GetModel(ctx context.Context, model string) (*Model, error) <span class="cov0" title="0">{
        modelList, err := client.GetModels(ctx, []string{model})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return modelList[0], nil</span>
}

func (client *Client) GetModels(ctx context.Context, models []string) ([]*Model, error) <span class="cov0" title="0">{
        stream, err := client.grpcConn.GetModels(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for _, model := range models </span><span class="cov0" title="0">{
                        stream.Send(&amp;pb.Name{Name: model})
                }</span>
                <span class="cov0" title="0">err := stream.CloseSend()
                if err != nil </span><span class="cov0" title="0">{
                        client.Logger.Errorw("Failed to close send", "Err", err)
                }</span>
        }()
        <span class="cov0" title="0">return client.parseModelStream(stream)</span>
}

type ModelDef struct {
        Name        string
        Description string
}

func (def ModelDef) ResourceType() ResourceType <span class="cov0" title="0">{
        return MODEL
}</span>

func (client *Client) CreateModel(ctx context.Context, def ModelDef) error <span class="cov0" title="0">{
        serialized := &amp;pb.Model{
                Name:        def.Name,
                Description: def.Description,
        }
        _, err := client.grpcConn.CreateModel(ctx, serialized)
        return err
}</span>

type modelStream interface {
        Recv() (*pb.Model, error)
}

func (client *Client) parseModelStream(stream modelStream) ([]*Model, error) <span class="cov0" title="0">{
        models := make([]*Model, 0)
        for </span><span class="cov0" title="0">{
                serial, err := stream.Recv()
                if err == io.EOF </span><span class="cov0" title="0">{
                        break</span>
                } else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">models = append(models, wrapProtoModel(serial))</span>
        }
        <span class="cov0" title="0">return models, nil</span>
}

type protoStringer struct {
        msg proto.Message
}

func (stringer protoStringer) String() string <span class="cov0" title="0">{
        bytes, err := protojson.Marshal(stringer.msg)
        if err != nil </span><span class="cov0" title="0">{
                return err.Error()
        }</span>
        <span class="cov0" title="0">return string(bytes)</span>
}

type createdGetter interface {
        GetCreated() string
}

type createdFn struct {
        getter createdGetter
}

func (fn createdFn) Created() time.Time <span class="cov0" title="0">{
        t, err := time.Parse(TIME_FORMAT, fn.getter.GetCreated())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return t</span>
}

type variantsDescriber interface {
        GetName() string
        GetDefaultVariant() string
        GetVariants() []string
}

type variantsFns struct {
        getter variantsDescriber
}

func (fns variantsFns) Name() string <span class="cov0" title="0">{
        return fns.getter.GetName()
}</span>

func (fns variantsFns) DefaultVariant() string <span class="cov0" title="0">{
        return fns.getter.GetDefaultVariant()
}</span>

func (fns variantsFns) Variants() []string <span class="cov0" title="0">{
        return fns.getter.GetVariants()
}</span>

func (fns variantsFns) NameVariants() []NameVariant <span class="cov0" title="0">{
        name := fns.getter.GetName()
        variants := fns.getter.GetVariants()
        nameVariants := make([]NameVariant, len(variants))
        for i, variant := range variants </span><span class="cov0" title="0">{
                nameVariants[i] = NameVariant{
                        Name:    name,
                        Variant: variant,
                }
        }</span>
        <span class="cov0" title="0">return nameVariants</span>
}

type trainingSetsGetter interface {
        GetTrainingsets() []*pb.NameVariant
}

type fetchTrainingSetsFns struct {
        getter trainingSetsGetter
}

func (fn fetchTrainingSetsFns) TrainingSets() []NameVariant <span class="cov0" title="0">{
        return parseNameVariants(fn.getter.GetTrainingsets())
}</span>

func (fn fetchTrainingSetsFns) FetchTrainingSets(client *Client, ctx context.Context) ([]*TrainingSetVariant, error) <span class="cov0" title="0">{
        return client.GetTrainingSetVariants(ctx, fn.TrainingSets())
}</span>

type labelsGetter interface {
        GetLabels() []*pb.NameVariant
}

type fetchLabelsFns struct {
        getter labelsGetter
}

func (fn fetchLabelsFns) Labels() []NameVariant <span class="cov0" title="0">{
        return parseNameVariants(fn.getter.GetLabels())
}</span>

func (fn fetchLabelsFns) FetchLabels(client *Client, ctx context.Context) ([]*LabelVariant, error) <span class="cov0" title="0">{
        return client.GetLabelVariants(ctx, fn.Labels())
}</span>

type featuresGetter interface {
        GetFeatures() []*pb.NameVariant
}

type fetchFeaturesFns struct {
        getter featuresGetter
}

func (fn fetchFeaturesFns) Features() []NameVariant <span class="cov0" title="0">{
        return parseNameVariants(fn.getter.GetFeatures())
}</span>

func (fn fetchFeaturesFns) FetchFeatures(client *Client, ctx context.Context) ([]*FeatureVariant, error) <span class="cov0" title="0">{
        return client.GetFeatureVariants(ctx, fn.Features())
}</span>

type sourcesGetter interface {
        GetSources() []*pb.NameVariant
}

type fetchSourcesFns struct {
        getter sourcesGetter
}

func (fn fetchSourcesFns) Sources() []NameVariant <span class="cov0" title="0">{
        return parseNameVariants(fn.getter.GetSources())
}</span>

func (fn fetchSourcesFns) FetchSources(client *Client, ctx context.Context) ([]*SourceVariant, error) <span class="cov0" title="0">{
        return client.GetSourceVariants(ctx, fn.Sources())
}</span>

type sourceGetter interface {
        GetSource() *pb.NameVariant
}

type fetchSourceFns struct {
        getter sourceGetter
}

func (fn fetchSourceFns) Source() NameVariant <span class="cov0" title="0">{
        return parseNameVariant(fn.getter.GetSource())
}</span>

func (fn fetchSourceFns) FetchSource(client *Client, ctx context.Context) (*SourceVariant, error) <span class="cov0" title="0">{
        return client.GetSourceVariant(ctx, fn.Source())
}</span>

type Feature struct {
        serialized *pb.Feature
        variantsFns
        protoStringer
}

func wrapProtoFeature(serialized *pb.Feature) *Feature <span class="cov0" title="0">{
        return &amp;Feature{
                serialized:    serialized,
                variantsFns:   variantsFns{serialized},
                protoStringer: protoStringer{serialized},
        }
}</span>

func (feature Feature) FetchVariants(client *Client, ctx context.Context) ([]*FeatureVariant, error) <span class="cov0" title="0">{
        return client.GetFeatureVariants(ctx, feature.NameVariants())
}</span>

type FeatureVariant struct {
        serialized *pb.FeatureVariant
        fetchTrainingSetsFns
        createdFn
        protoStringer
}

func wrapProtoFeatureVariant(serialized *pb.FeatureVariant) *FeatureVariant <span class="cov0" title="0">{
        return &amp;FeatureVariant{
                serialized:           serialized,
                fetchTrainingSetsFns: fetchTrainingSetsFns{serialized},
                createdFn:            createdFn{serialized},
                protoStringer:        protoStringer{serialized},
        }
}</span>

func (variant *FeatureVariant) Name() string <span class="cov0" title="0">{
        return variant.serialized.GetName()
}</span>

func (variant *FeatureVariant) Provider() string <span class="cov0" title="0">{
        return variant.serialized.GetProvider()
}</span>

func (variant *FeatureVariant) Description() string <span class="cov0" title="0">{
        return variant.serialized.GetDescription()
}</span>

func (variant *FeatureVariant) Variant() string <span class="cov0" title="0">{
        return variant.serialized.GetVariant()
}</span>

func (variant *FeatureVariant) Source() NameVariant <span class="cov0" title="0">{
        return parseNameVariant(variant.serialized.GetSource())
}</span>

func (variant *FeatureVariant) Type() string <span class="cov0" title="0">{
        return variant.serialized.GetType()
}</span>

func (variant *FeatureVariant) Entity() string <span class="cov0" title="0">{
        return variant.serialized.GetEntity()
}</span>

func (variant *FeatureVariant) Owner() string <span class="cov0" title="0">{
        return variant.serialized.GetOwner()
}</span>

type User struct {
        serialized *pb.User
        fetchTrainingSetsFns
        fetchFeaturesFns
        fetchLabelsFns
        fetchSourcesFns
        protoStringer
}

func wrapProtoUser(serialized *pb.User) *User <span class="cov0" title="0">{
        return &amp;User{
                serialized:           serialized,
                fetchTrainingSetsFns: fetchTrainingSetsFns{serialized},
                fetchFeaturesFns:     fetchFeaturesFns{serialized},
                fetchLabelsFns:       fetchLabelsFns{serialized},
                fetchSourcesFns:      fetchSourcesFns{serialized},
                protoStringer:        protoStringer{serialized},
        }
}</span>

func (user *User) Name() string <span class="cov0" title="0">{
        return user.serialized.GetName()
}</span>

type Provider struct {
        serialized *pb.Provider
        fetchTrainingSetsFns
        fetchFeaturesFns
        fetchLabelsFns
        fetchSourcesFns
        protoStringer
}

func wrapProtoProvider(serialized *pb.Provider) *Provider <span class="cov0" title="0">{
        return &amp;Provider{
                serialized:           serialized,
                fetchTrainingSetsFns: fetchTrainingSetsFns{serialized},
                fetchFeaturesFns:     fetchFeaturesFns{serialized},
                fetchLabelsFns:       fetchLabelsFns{serialized},
                fetchSourcesFns:      fetchSourcesFns{serialized},
                protoStringer:        protoStringer{serialized},
        }
}</span>

func (provider *Provider) Name() string <span class="cov0" title="0">{
        return provider.serialized.GetName()
}</span>

func (provider *Provider) Description() string <span class="cov0" title="0">{
        return provider.serialized.GetDescription()
}</span>

func (provider *Provider) Type() string <span class="cov0" title="0">{
        return provider.serialized.GetType()
}</span>

func (provider *Provider) Software() string <span class="cov0" title="0">{
        return provider.serialized.GetSoftware()
}</span>

func (provider *Provider) Team() string <span class="cov0" title="0">{
        return provider.serialized.GetTeam()
}</span>

type Model struct {
        serialized *pb.Model
        fetchTrainingSetsFns
        fetchFeaturesFns
        fetchLabelsFns
        protoStringer
}

func wrapProtoModel(serialized *pb.Model) *Model <span class="cov0" title="0">{
        return &amp;Model{
                serialized:           serialized,
                fetchTrainingSetsFns: fetchTrainingSetsFns{serialized},
                fetchFeaturesFns:     fetchFeaturesFns{serialized},
                fetchLabelsFns:       fetchLabelsFns{serialized},
                protoStringer:        protoStringer{serialized},
        }
}</span>

func (model *Model) Name() string <span class="cov0" title="0">{
        return model.serialized.GetName()
}</span>

func (model *Model) Description() string <span class="cov0" title="0">{
        return model.serialized.GetDescription()
}</span>

type Label struct {
        serialized *pb.Label
        variantsFns
        protoStringer
}

func wrapProtoLabel(serialized *pb.Label) *Label <span class="cov0" title="0">{
        return &amp;Label{
                serialized:    serialized,
                variantsFns:   variantsFns{serialized},
                protoStringer: protoStringer{serialized},
        }
}</span>

func (label Label) FetchVariants(client *Client, ctx context.Context) ([]*LabelVariant, error) <span class="cov0" title="0">{
        return client.GetLabelVariants(ctx, label.NameVariants())
}</span>

type LabelVariant struct {
        serialized *pb.LabelVariant
        fetchTrainingSetsFns
        createdFn
        protoStringer
}

func wrapProtoLabelVariant(serialized *pb.LabelVariant) *LabelVariant <span class="cov0" title="0">{
        return &amp;LabelVariant{
                serialized:           serialized,
                fetchTrainingSetsFns: fetchTrainingSetsFns{serialized},
                createdFn:            createdFn{serialized},
                protoStringer:        protoStringer{serialized},
        }
}</span>

func (variant *LabelVariant) Name() string <span class="cov0" title="0">{
        return variant.serialized.GetName()
}</span>

func (variant *LabelVariant) Description() string <span class="cov0" title="0">{
        return variant.serialized.GetDescription()
}</span>

func (variant *LabelVariant) Variant() string <span class="cov0" title="0">{
        return variant.serialized.GetVariant()
}</span>

func (variant *LabelVariant) Source() NameVariant <span class="cov0" title="0">{
        return parseNameVariant(variant.serialized.GetSource())
}</span>

func (variant *LabelVariant) Type() string <span class="cov0" title="0">{
        return variant.serialized.GetType()
}</span>

func (variant *LabelVariant) Entity() string <span class="cov0" title="0">{
        return variant.serialized.GetEntity()
}</span>

func (variant *LabelVariant) Owner() string <span class="cov0" title="0">{
        return variant.serialized.GetOwner()
}</span>

func (variant *LabelVariant) Provider() string <span class="cov0" title="0">{
        return variant.serialized.GetProvider()
}</span>

type TrainingSet struct {
        serialized *pb.TrainingSet
        variantsFns
        protoStringer
}

func wrapProtoTrainingSet(serialized *pb.TrainingSet) *TrainingSet <span class="cov0" title="0">{
        return &amp;TrainingSet{
                serialized:    serialized,
                variantsFns:   variantsFns{serialized},
                protoStringer: protoStringer{serialized},
        }
}</span>

func (trainingSet TrainingSet) FetchVariants(client *Client, ctx context.Context) ([]*TrainingSetVariant, error) <span class="cov0" title="0">{
        return client.GetTrainingSetVariants(ctx, trainingSet.NameVariants())
}</span>

type TrainingSetVariant struct {
        serialized *pb.TrainingSetVariant
        fetchFeaturesFns
        createdFn
        protoStringer
}

func wrapProtoTrainingSetVariant(serialized *pb.TrainingSetVariant) *TrainingSetVariant <span class="cov0" title="0">{
        return &amp;TrainingSetVariant{
                serialized:       serialized,
                fetchFeaturesFns: fetchFeaturesFns{serialized},
                createdFn:        createdFn{serialized},
                protoStringer:    protoStringer{serialized},
        }
}</span>

func (variant *TrainingSetVariant) Name() string <span class="cov0" title="0">{
        return variant.serialized.GetName()
}</span>

func (variant *TrainingSetVariant) Description() string <span class="cov0" title="0">{
        return variant.serialized.GetDescription()
}</span>

func (variant *TrainingSetVariant) Variant() string <span class="cov0" title="0">{
        return variant.serialized.GetVariant()
}</span>

func (variant *TrainingSetVariant) Provider() string <span class="cov0" title="0">{
        return variant.serialized.GetProvider()
}</span>

func (variant *TrainingSetVariant) Owner() string <span class="cov0" title="0">{
        return variant.serialized.GetOwner()
}</span>

func (variant *TrainingSetVariant) Label() NameVariant <span class="cov0" title="0">{
        return parseNameVariant(variant.serialized.GetLabel())
}</span>

func (variant *TrainingSetVariant) FetchLabel(client *Client, ctx context.Context) (*LabelVariant, error) <span class="cov0" title="0">{
        labelList, err := client.GetLabelVariants(ctx, []NameVariant{variant.Label()})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return labelList[0], nil</span>
}

type Source struct {
        serialized *pb.Source
        variantsFns
        protoStringer
}

func wrapProtoSource(serialized *pb.Source) *Source <span class="cov0" title="0">{
        return &amp;Source{
                serialized:    serialized,
                variantsFns:   variantsFns{serialized},
                protoStringer: protoStringer{serialized},
        }
}</span>

func (source Source) FetchVariants(client *Client, ctx context.Context) ([]*SourceVariant, error) <span class="cov0" title="0">{
        return client.GetSourceVariants(ctx, source.NameVariants())
}</span>

type SourceVariant struct {
        serialized *pb.SourceVariant
        fetchTrainingSetsFns
        fetchFeaturesFns
        fetchLabelsFns
        createdFn
        protoStringer
}

func wrapProtoSourceVariant(serialized *pb.SourceVariant) *SourceVariant <span class="cov0" title="0">{
        return &amp;SourceVariant{
                serialized:           serialized,
                fetchTrainingSetsFns: fetchTrainingSetsFns{serialized},
                fetchFeaturesFns:     fetchFeaturesFns{serialized},
                fetchLabelsFns:       fetchLabelsFns{serialized},
                createdFn:            createdFn{serialized},
                protoStringer:        protoStringer{serialized},
        }
}</span>

func (variant *SourceVariant) Name() string <span class="cov0" title="0">{
        return variant.serialized.GetName()
}</span>

func (variant *SourceVariant) Variant() string <span class="cov0" title="0">{
        return variant.serialized.GetVariant()
}</span>

func (variant *SourceVariant) Description() string <span class="cov0" title="0">{
        return variant.serialized.GetDescription()
}</span>

func (variant *SourceVariant) Type() string <span class="cov0" title="0">{
        return variant.serialized.GetType()
}</span>

func (variant *SourceVariant) Provider() string <span class="cov0" title="0">{
        return variant.serialized.GetProvider()
}</span>

func (variant *SourceVariant) Owner() string <span class="cov0" title="0">{
        return variant.serialized.GetOwner()
}</span>

type Entity struct {
        serialized *pb.Entity
        fetchTrainingSetsFns
        fetchFeaturesFns
        fetchLabelsFns
        protoStringer
}

func wrapProtoEntity(serialized *pb.Entity) *Entity <span class="cov0" title="0">{
        return &amp;Entity{
                serialized:           serialized,
                fetchTrainingSetsFns: fetchTrainingSetsFns{serialized},
                fetchFeaturesFns:     fetchFeaturesFns{serialized},
                fetchLabelsFns:       fetchLabelsFns{serialized},
                protoStringer:        protoStringer{serialized},
        }
}</span>

func (entity *Entity) Name() string <span class="cov0" title="0">{
        return entity.serialized.GetName()
}</span>

func (entity *Entity) Description() string <span class="cov0" title="0">{
        return entity.serialized.GetDescription()
}</span>

func NewClient(host string, logger *zap.SugaredLogger) (*Client, error) <span class="cov0" title="0">{
        opts := []grpc.DialOption{
                grpc.WithTransportCredentials(insecure.NewCredentials()),
        }
        conn, err := grpc.Dial(host, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">client := pb.NewMetadataClient(conn)
        return &amp;Client{
                Logger:   logger,
                conn:     conn,
                grpcConn: client,
        }, nil</span>
}

func (client *Client) Close() <span class="cov0" title="0">{
        client.conn.Close()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "context"
        "fmt"

        "github.com/featureform/serving/metadata"
        "go.uber.org/zap"
)

func main() <span class="cov0" title="0">{
        logger := zap.NewExample().Sugar()
        client, err := metadata.NewClient("localhost:8080", logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicw("Failed to connect", "Err", err)
        }</span>

        <span class="cov0" title="0">defs := []metadata.ResourceDef{
                metadata.UserDef{
                        Name: "Simba Khadder",
                },
                metadata.ProviderDef{
                        Name:        "demo-s3",
                        Description: "local S3 deployment",
                        Type:        "Batch",
                        Software:    "BigQuery",
                        Team:        "",
                },
                metadata.ProviderDef{
                        Name:        "demo-redis",
                        Description: "Bitnami redis deployment",
                        Type:        "Online",
                        Software:    "Redis",
                        Team:        "",
                },
                metadata.EntityDef{
                        Name:        "user",
                        Description: "user description",
                },
                metadata.SourceDef{
                        Name:        "Transactions",
                        Variant:     "default",
                        Description: "Source of user transactions",
                        Type:        "CSV",
                        Owner:       "Simba Khadder",
                        Provider:    "demo-redis",
                },
                metadata.LabelDef{
                        Name:        "is_fraud",
                        Variant:     "default",
                        Description: "if a transaction is fraud",
                        Type:        "boolean",
                        Source:      metadata.NameVariant{"Transactions", "default"},
                        Entity:      "user",
                        Owner:       "Simba Khadder",
                        Provider:    "demo-redis",
                },
                metadata.FeatureDef{
                        Name:        "number_of_fraud",
                        Variant:     "90d",
                        Source:      metadata.NameVariant{"Transactions", "default"},
                        Type:        "int",
                        Entity:      "user",
                        Owner:       "Simba Khadder",
                        Description: "Number of fraud transactions in the last 90 days.",
                        Provider:    "demo-redis",
                },
                metadata.FeatureDef{
                        Name:        "user_2fa",
                        Variant:     "default",
                        Source:      metadata.NameVariant{"Transactions", "default"},
                        Type:        "boolean",
                        Entity:      "user",
                        Owner:       "Simba Khadder",
                        Description: "If user has 2fa",
                        Provider:    "demo-redis",
                },
                metadata.FeatureDef{
                        Name:        "user_account_age",
                        Variant:     "default",
                        Source:      metadata.NameVariant{"Transactions", "default"},
                        Type:        "int",
                        Entity:      "user",
                        Owner:       "Simba Khadder",
                        Description: "Seconds since the user's account was created.",
                        Provider:    "demo-redis",
                },
                metadata.FeatureDef{
                        Name:        "user_credit_score",
                        Variant:     "default",
                        Source:      metadata.NameVariant{"Transactions", "default"},
                        Type:        "int",
                        Entity:      "user",
                        Owner:       "Simba Khadder",
                        Description: "User's credit score",
                        Provider:    "demo-s3",
                },
                metadata.FeatureDef{
                        Name:        "user_transaction_count",
                        Variant:     "30d",
                        Source:      metadata.NameVariant{"Transactions", "default"},
                        Type:        "int",
                        Entity:      "user",
                        Owner:       "Simba Khadder",
                        Description: "Number of transcations the user performed in the last 30 days.",
                        Provider:    "demo-redis",
                },
                metadata.FeatureDef{
                        Name:        "avg_transaction_amt",
                        Variant:     "default",
                        Source:      metadata.NameVariant{"Transactions", "default"},
                        Type:        "int",
                        Entity:      "user",
                        Owner:       "Simba Khadder",
                        Description: "Average transaction amount",
                        Provider:    "demo-redis",
                },
                metadata.FeatureDef{
                        Name:        "amt_spent",
                        Variant:     "30d",
                        Source:      metadata.NameVariant{"Transactions", "default"},
                        Type:        "int",
                        Entity:      "user",
                        Owner:       "Simba Khadder",
                        Description: "Total amount spent in the last 30 days.",
                        Provider:    "demo-redis",
                },
                metadata.FeatureDef{
                        Name:        "user_transaction_count",
                        Variant:     "7d",
                        Source:      metadata.NameVariant{"Transactions", "default"},
                        Type:        "int",
                        Entity:      "user",
                        Owner:       "Simba Khadder",
                        Description: "Number of transcations the user performed in the last 7 days.",
                        Provider:    "demo-s3",
                },
                metadata.TrainingSetDef{
                        Name:        "is_fraud",
                        Variant:     "default",
                        Description: "if a transaction is fraud",
                        Owner:       "Simba Khadder",
                        Provider:    "demo-s3",
                        Label:       metadata.NameVariant{"is_fraud", "default"},
                        Features:    []metadata.NameVariant{{"user_transaction_count", "7d"}, {"number_of_fraud", "90d"}, {"amt_spent", "30d"}, {"avg_transaction_amt", "default"}, {"user_account_age", "default"}, {"user_credit_score", "default"}, {"user_2fa", "default"}},
                },
                metadata.ModelDef{
                        Name:        "user_fraud_random_forest",
                        Description: "Classifier on whether user commited fraud",
                },
        }
        if err := client.CreateAll(context.Background(), defs); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">entities, err := client.ListEntities(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">fmt.Printf("Entities: %+v\n", entities)

        providers, err := client.ListProviders(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">fmt.Printf("Providers: %+v\n", providers)

        users, err := client.ListEntities(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">fmt.Printf("Entities: %+v\n", users)

        sources, err := client.ListSources(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">fmt.Printf("Sources: %+v\n", sources)

        new_providers, err := client.ListProviders(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">fmt.Printf("Providers: %+v\n", new_providers)

        features, err := client.ListFeatures(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">fmt.Printf("Features: %+v\n", features)

        labels, err := client.ListLabels(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">fmt.Printf("Labels: %+v\n", labels)

        trainingSets, err := client.ListTrainingSets(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">fmt.Printf("Training Sets: %+v\n", trainingSets)

        models, err := client.ListModels(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">fmt.Printf("Models: %+v\n", models)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "fmt"
        "github.com/featureform/serving/metadata"
        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        "go.uber.org/zap"
        "golang.org/x/sync/errgroup"
        "net/http"
        "time"
)

type MetadataServer struct {
        client *metadata.Client
        logger *zap.SugaredLogger
}

func NewMetadataServer(logger *zap.SugaredLogger, client *metadata.Client) (*MetadataServer, error) <span class="cov0" title="0">{
        logger.Debug("Creating new metadata server")
        return &amp;MetadataServer{
                client: client,
                logger: logger,
        }, nil
}</span>

type FeatureVariantResource struct {
        Created      time.Time                               `json:"created"`
        Description  string                                  `json:"description"`
        Entity       string                                  `json:"entity"`
        Name         string                                  `json:"name"`
        Owner        string                                  `json:"owner"`
        Provider     string                                  `json:"provider"`
        Type         string                                  `json:"type"`
        Variant      string                                  `json:"variant"`
        Source       metadata.NameVariant                    `json:"source"`
        TrainingSets map[string][]TrainingSetVariantResource `json:"training-sets"`
}

type FeatureResource struct {
        AllVariants    []string                          `json:"all-variants"`
        Type           string                            `json:"type"`
        DefaultVariant string                            `json:"default-variant"`
        Name           string                            `json:"name"`
        Variants       map[string]FeatureVariantResource `json:"variants"`
}

type TrainingSetVariantResource struct {
        Created     time.Time                           `json:"created"`
        Description string                              `json:"description"`
        Name        string                              `json:"name"`
        Owner       string                              `json:"owner"`
        Provider    string                              `json:"provider"`
        Variant     string                              `json:"variant"`
        Label       metadata.NameVariant                `json:"label"`
        Features    map[string][]FeatureVariantResource `json:"features"`
}

type TrainingSetResource struct {
        AllVariants    []string                              `json:"all-variants"`
        Type           string                                `json:"type"`
        DefaultVariant string                                `json:"default-variant"`
        Name           string                                `json:"name"`
        Variants       map[string]TrainingSetVariantResource `json:"variants"`
}

type SourceVariantResource struct {
        Created      time.Time                               `json:"created"`
        Description  string                                  `json:"description"`
        Name         string                                  `json:"name"`
        Type         string                                  `json:"type"`
        Owner        string                                  `json:"owner"`
        Provider     string                                  `json:"provider"`
        Variant      string                                  `json:"variant"`
        Labels       map[string][]LabelVariantResource       `json:"labels"`
        Features     map[string][]FeatureVariantResource     `json:"features"`
        TrainingSets map[string][]TrainingSetVariantResource `json:"training-sets"`
}

type SourceResource struct {
        AllVariants    []string                         `json:"all-variants"`
        Type           string                           `json:"type"`
        DefaultVariant string                           `json:"default-variant"`
        Name           string                           `json:"name"`
        Variants       map[string]SourceVariantResource `json:"variants"`
}

type LabelVariantResource struct {
        Created      time.Time                               `json:"created"`
        Description  string                                  `json:"description"`
        Entity       string                                  `json:"entity"`
        Name         string                                  `json:"name"`
        Owner        string                                  `json:"owner"`
        Provider     string                                  `json:"provider"`
        Type         string                                  `json:"type"`
        Variant      string                                  `json:"variant"`
        Source       metadata.NameVariant                    `json:"source"`
        TrainingSets map[string][]TrainingSetVariantResource `json:"training-sets"`
}

type LabelResource struct {
        AllVariants    []string                        `json:"all-variants"`
        Type           string                          `json:"type"`
        DefaultVariant string                          `json:"default-variant"`
        Name           string                          `json:"name"`
        Variants       map[string]LabelVariantResource `json:"variants"`
}

type EntityResource struct {
        Name         string                                  `json:"name"`
        Type         string                                  `json:"type"`
        Description  string                                  `json:"description"`
        Features     map[string][]FeatureVariantResource     `json:"features"`
        Labels       map[string][]LabelVariantResource       `json:"labels"`
        TrainingSets map[string][]TrainingSetVariantResource `json:"training-sets"`
}

type UserResource struct {
        Name         string                                  `json:"name"`
        Type         string                                  `json:"type"`
        Features     map[string][]FeatureVariantResource     `json:"features"`
        Labels       map[string][]LabelVariantResource       `json:"labels"`
        TrainingSets map[string][]TrainingSetVariantResource `json:"training-sets"`
        Sources      map[string][]SourceVariantResource      `json:"primary-data"`
}

type ModelResource struct {
        Name         string                                  `json:"name"`
        Type         string                                  `json:"type"`
        Description  string                                  `json:"description"`
        Features     map[string][]FeatureVariantResource     `json:"features"`
        Labels       map[string][]LabelVariantResource       `json:"labels"`
        TrainingSets map[string][]TrainingSetVariantResource `json:"trainingsets"`
}

type ProviderResource struct {
        Name         string                                  `json:"name"`
        Type         string                                  `json:"type"`
        Description  string                                  `json:"description"`
        ProviderType string                                  `json:"provider-type"`
        Software     string                                  `json:"software"`
        Team         string                                  `json:"team"`
        Sources      map[string][]SourceVariantResource      `json:"primary-data"`
        Features     map[string][]FeatureVariantResource     `json:"features"`
        Labels       map[string][]LabelVariantResource       `json:"labels"`
        TrainingSets map[string][]TrainingSetVariantResource `json:"trainingsets"`
}

type FetchError struct {
        StatusCode int
        Type       string
}

func (m *FetchError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Error %d: Failed to fetch %s", m.StatusCode, m.Type)
}</span>

func featureShallowMap(variant *metadata.FeatureVariant) FeatureVariantResource <span class="cov0" title="0">{
        return FeatureVariantResource{
                Created:     variant.Created(),
                Description: variant.Description(),
                Entity:      variant.Entity(),
                Name:        variant.Name(),
                Type:        variant.Type(),
                Variant:     variant.Variant(),
                Owner:       variant.Owner(),
                Provider:    variant.Provider(),
                Source:      variant.Source(),
        }
}</span>

func labelShallowMap(variant *metadata.LabelVariant) LabelVariantResource <span class="cov0" title="0">{
        return LabelVariantResource{
                Created:     variant.Created(),
                Description: variant.Description(),
                Entity:      variant.Entity(),
                Name:        variant.Name(),
                Type:        variant.Type(),
                Variant:     variant.Variant(),
                Owner:       variant.Owner(),
                Provider:    variant.Provider(),
                Source:      variant.Source(),
        }
}</span>

func trainingSetShallowMap(variant *metadata.TrainingSetVariant) TrainingSetVariantResource <span class="cov0" title="0">{
        return TrainingSetVariantResource{
                Created:     variant.Created(),
                Description: variant.Description(),
                Name:        variant.Name(),
                Variant:     variant.Variant(),
                Owner:       variant.Owner(),
                Provider:    variant.Provider(),
                Label:       variant.Label(),
        }
}</span>

func sourceShallowMap(variant *metadata.SourceVariant) SourceVariantResource <span class="cov0" title="0">{
        return SourceVariantResource{
                Created:     variant.Created(),
                Description: variant.Description(),
                Name:        variant.Name(),
                Type:        variant.Type(),
                Variant:     variant.Variant(),
                Owner:       variant.Owner(),
                Provider:    variant.Provider(),
        }
}</span>

func (m *MetadataServer) getTrainingSets(nameVariants []metadata.NameVariant) (map[string][]TrainingSetVariantResource, error) <span class="cov0" title="0">{
        trainingSetMap := make(map[string][]TrainingSetVariantResource)
        trainingSetVariants, err := m.client.GetTrainingSetVariants(context.Background(), nameVariants)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, variant := range trainingSetVariants </span><span class="cov0" title="0">{
                if _, has := trainingSetMap[variant.Name()]; !has </span><span class="cov0" title="0">{
                        trainingSetMap[variant.Name()] = []TrainingSetVariantResource{}
                }</span>
                <span class="cov0" title="0">trainingSetMap[variant.Name()] = append(trainingSetMap[variant.Name()], trainingSetShallowMap(variant))</span>
        }
        <span class="cov0" title="0">return trainingSetMap, nil</span>
}

func (m *MetadataServer) getFeatures(nameVariants []metadata.NameVariant) (map[string][]FeatureVariantResource, error) <span class="cov0" title="0">{
        featureMap := make(map[string][]FeatureVariantResource)
        featureVariants, err := m.client.GetFeatureVariants(context.Background(), nameVariants)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, variant := range featureVariants </span><span class="cov0" title="0">{
                if _, has := featureMap[variant.Name()]; !has </span><span class="cov0" title="0">{
                        featureMap[variant.Name()] = []FeatureVariantResource{}
                }</span>
                <span class="cov0" title="0">featureMap[variant.Name()] = append(featureMap[variant.Name()], featureShallowMap(variant))</span>
        }
        <span class="cov0" title="0">return featureMap, nil</span>
}

func (m *MetadataServer) getLabels(nameVariants []metadata.NameVariant) (map[string][]LabelVariantResource, error) <span class="cov0" title="0">{
        labelMap := make(map[string][]LabelVariantResource)
        labelVariants, err := m.client.GetLabelVariants(context.Background(), nameVariants)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, variant := range labelVariants </span><span class="cov0" title="0">{
                if _, has := labelMap[variant.Name()]; !has </span><span class="cov0" title="0">{
                        labelMap[variant.Name()] = []LabelVariantResource{}
                }</span>
                <span class="cov0" title="0">labelMap[variant.Name()] = append(labelMap[variant.Name()], labelShallowMap(variant))</span>
        }
        <span class="cov0" title="0">return labelMap, nil</span>
}

func (m *MetadataServer) getSources(nameVariants []metadata.NameVariant) (map[string][]SourceVariantResource, error) <span class="cov0" title="0">{
        sourceMap := make(map[string][]SourceVariantResource)
        sourceVariants, err := m.client.GetSourceVariants(context.Background(), nameVariants)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">for _, variant := range sourceVariants </span><span class="cov0" title="0">{
                if _, has := sourceMap[variant.Name()]; !has </span><span class="cov0" title="0">{
                        sourceMap[variant.Name()] = []SourceVariantResource{}
                }</span>
                <span class="cov0" title="0">sourceMap[variant.Name()] = append(sourceMap[variant.Name()], sourceShallowMap(variant))</span>
        }
        <span class="cov0" title="0">return sourceMap, nil</span>
}

func (m *MetadataServer) readFromFeature(feature *metadata.Feature, deepCopy bool) (map[string]FeatureVariantResource, *FetchError) <span class="cov0" title="0">{
        variantMap := make(map[string]FeatureVariantResource)
        variants, err := feature.FetchVariants(m.client, context.Background())
        if err != nil </span><span class="cov0" title="0">{
                fetchError := &amp;FetchError{StatusCode: 500, Type: "feature variants"}
                m.logger.Errorw(fetchError.Error(), "Internal Error", err)
                return nil, fetchError
        }</span>
        <span class="cov0" title="0">for _, variant := range variants </span><span class="cov0" title="0">{

                featResource := featureShallowMap(variant)
                if deepCopy </span><span class="cov0" title="0">{
                        ts, err := m.getTrainingSets(variant.TrainingSets())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal Error", err)
                                return nil, &amp;FetchError{StatusCode: 500, Type: "Cannot get information from training sets"}
                        }</span>
                        <span class="cov0" title="0">featResource.TrainingSets = ts</span>
                }
                <span class="cov0" title="0">variantMap[variant.Variant()] = featResource</span>

        }
        <span class="cov0" title="0">return variantMap, nil</span>
}

func (m *MetadataServer) readFromTrainingSet(trainingSet *metadata.TrainingSet, deepCopy bool) (map[string]TrainingSetVariantResource, *FetchError) <span class="cov0" title="0">{
        variantMap := make(map[string]TrainingSetVariantResource)
        variants, err := trainingSet.FetchVariants(m.client, context.Background())
        if err != nil </span><span class="cov0" title="0">{
                fetchError := &amp;FetchError{StatusCode: 500, Type: "training set variants"}
                m.logger.Errorw(fetchError.Error(), "Internal Error", err)
                return nil, fetchError
        }</span>
        <span class="cov0" title="0">for _, variant := range variants </span><span class="cov0" title="0">{

                trainingResource := trainingSetShallowMap(variant)
                if deepCopy </span><span class="cov0" title="0">{
                        f, err := m.getFeatures(variant.Features())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal Error", err)
                                return nil, &amp;FetchError{StatusCode: 500, Type: "Cannot get information from features"}
                        }</span>
                        <span class="cov0" title="0">trainingResource.Features = f</span>
                }
                <span class="cov0" title="0">variantMap[variant.Variant()] = trainingResource</span>

        }
        <span class="cov0" title="0">return variantMap, nil</span>
}

func (m *MetadataServer) readFromSource(source *metadata.Source, deepCopy bool) (map[string]SourceVariantResource, *FetchError) <span class="cov0" title="0">{
        variantMap := make(map[string]SourceVariantResource)
        variants, err := source.FetchVariants(m.client, context.Background())
        if err != nil </span><span class="cov0" title="0">{
                fetchError := &amp;FetchError{StatusCode: 500, Type: "source variants"}
                m.logger.Errorw(fetchError.Error(), "Internal Error", err)
                return nil, fetchError
        }</span>
        <span class="cov0" title="0">for _, variant := range variants </span><span class="cov0" title="0">{

                sourceResource := sourceShallowMap(variant)
                if deepCopy </span><span class="cov0" title="0">{
                        fetchGroup := new(errgroup.Group)
                        fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                                f, err := m.getFeatures(variant.Features())
                                if err != nil </span><span class="cov0" title="0">{
                                        m.logger.Errorw(err.Error(), "Internal Error", err)
                                        return &amp;FetchError{StatusCode: 500, Type: "Cannot get information from features"}
                                }</span>
                                <span class="cov0" title="0">sourceResource.Features = f
                                return nil</span>
                        })
                        <span class="cov0" title="0">fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                                l, err := m.getLabels(variant.Labels())
                                if err != nil </span><span class="cov0" title="0">{
                                        m.logger.Errorw(err.Error(), "Internal Error", err)
                                        return &amp;FetchError{StatusCode: 500, Type: "Cannot get information from labels"}
                                }</span>
                                <span class="cov0" title="0">sourceResource.Labels = l
                                return nil</span>
                        })
                        <span class="cov0" title="0">fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                                ts, err := m.getTrainingSets(variant.TrainingSets())
                                if err != nil </span><span class="cov0" title="0">{
                                        m.logger.Errorw(err.Error(), "Internal Error", err)
                                        return &amp;FetchError{StatusCode: 500, Type: "Cannot get information from training sets"}
                                }</span>
                                <span class="cov0" title="0">sourceResource.TrainingSets = ts
                                return nil</span>
                        })
                        <span class="cov0" title="0">if err := fetchGroup.Wait(); err != nil </span><span class="cov0" title="0">{
                                return nil, err.(*FetchError)
                        }</span>
                }
                <span class="cov0" title="0">variantMap[variant.Variant()] = sourceResource</span>

        }
        <span class="cov0" title="0">return variantMap, nil</span>
}

func (m *MetadataServer) readFromLabel(label *metadata.Label, deepCopy bool) (map[string]LabelVariantResource, *FetchError) <span class="cov0" title="0">{
        variantMap := make(map[string]LabelVariantResource)
        variants, err := label.FetchVariants(m.client, context.Background())
        if err != nil </span><span class="cov0" title="0">{
                fetchError := &amp;FetchError{StatusCode: 500, Type: "label variants"}
                m.logger.Errorw(fetchError.Error(), "Internal Error", err)
                return nil, fetchError
        }</span>
        <span class="cov0" title="0">for _, variant := range variants </span><span class="cov0" title="0">{
                labelResource := labelShallowMap(variant)
                if deepCopy </span><span class="cov0" title="0">{
                        ts, err := m.getTrainingSets(variant.TrainingSets())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal Error", err)
                                return nil, &amp;FetchError{StatusCode: 500, Type: "Cannot get information from training sets"}
                        }</span>
                        <span class="cov0" title="0">labelResource.TrainingSets = ts</span>
                }
                <span class="cov0" title="0">variantMap[variant.Variant()] = labelResource</span>
        }
        <span class="cov0" title="0">return variantMap, nil</span>
}

func (m *MetadataServer) GetMetadata(c *gin.Context) <span class="cov0" title="0">{
        switch c.Param("type") </span>{
        case "features":<span class="cov0" title="0">
                feature, err := m.client.GetFeature(context.Background(), c.Param("resource"))
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "feature"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">variantList, fetchError := m.readFromFeature(feature, true)
                if fetchError != nil </span><span class="cov0" title="0">{
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, FeatureResource{
                        AllVariants:    feature.Variants(),
                        Type:           "Feature",
                        DefaultVariant: feature.DefaultVariant(),
                        Name:           feature.Name(),
                        Variants:       variantList,
                })</span>
        case "labels":<span class="cov0" title="0">
                label, err := m.client.GetLabel(context.Background(), c.Param("resource"))
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "label"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">variantList, fetchError := m.readFromLabel(label, true)
                if fetchError != nil </span><span class="cov0" title="0">{
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, LabelResource{
                        AllVariants:    label.Variants(),
                        Type:           "Label",
                        DefaultVariant: label.DefaultVariant(),
                        Name:           label.Name(),
                        Variants:       variantList,
                })</span>
        case "training-sets":<span class="cov0" title="0">
                trainingSet, err := m.client.GetTrainingSet(context.Background(), c.Param("resource"))
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "training set"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">variantList, fetchError := m.readFromTrainingSet(trainingSet, true)
                if fetchError != nil </span><span class="cov0" title="0">{
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, TrainingSetResource{
                        AllVariants:    trainingSet.Variants(),
                        Type:           "TrainingSet",
                        DefaultVariant: trainingSet.DefaultVariant(),
                        Name:           trainingSet.Name(),
                        Variants:       variantList,
                })</span>
        case "primary-data":<span class="cov0" title="0">
                source, err := m.client.GetSource(context.Background(), c.Param("resource"))
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "source"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">variantList, fetchError := m.readFromSource(source, true)
                if fetchError != nil </span><span class="cov0" title="0">{
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, SourceResource{
                        AllVariants:    source.Variants(),
                        Type:           "PrimaryData",
                        DefaultVariant: source.DefaultVariant(),
                        Name:           source.Name(),
                        Variants:       variantList,
                })</span>
        case "entities":<span class="cov0" title="0">
                entity, err := m.client.GetEntity(context.Background(), c.Param("resource"))
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "entity"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">entityResource := EntityResource{
                        Name:        entity.Name(),
                        Type:        "Entity",
                        Description: entity.Description(),
                }
                fetchGroup := new(errgroup.Group)
                fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                        f, err := m.getFeatures(entity.Features())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal error", err)
                                return &amp;FetchError{StatusCode: 500, Type: "feature"}
                        }</span>
                        <span class="cov0" title="0">entityResource.Features = f
                        return nil</span>
                })
                <span class="cov0" title="0">fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                        l, err := m.getLabels(entity.Labels())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal error", err)
                                return &amp;FetchError{StatusCode: 500, Type: "label"}
                        }</span>
                        <span class="cov0" title="0">entityResource.Labels = l
                        return nil</span>
                })
                <span class="cov0" title="0">fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                        ts, err := m.getTrainingSets(entity.TrainingSets())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal error", err)
                                return &amp;FetchError{StatusCode: 500, Type: "training set"}
                        }</span>
                        <span class="cov0" title="0">entityResource.TrainingSets = ts
                        return nil</span>
                })
                <span class="cov0" title="0">if err := fetchGroup.Wait(); err != nil </span><span class="cov0" title="0">{
                        c.JSON(err.(*FetchError).StatusCode, err.Error())
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, entityResource)</span>
        case "users":<span class="cov0" title="0">
                user, err := m.client.GetUser(context.Background(), c.Param("resource"))
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "user"}
                        m.logger.Errorw(err.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">userResource := &amp;UserResource{
                        Name: user.Name(),
                        Type: "User",
                }
                fetchGroup := new(errgroup.Group)
                fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                        f, err := m.getFeatures(user.Features())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal error", err)
                                return &amp;FetchError{StatusCode: 500, Type: "feature"}
                        }</span>
                        <span class="cov0" title="0">userResource.Features = f
                        return nil</span>
                })
                <span class="cov0" title="0">fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                        l, err := m.getLabels(user.Labels())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal error", err)
                                return &amp;FetchError{StatusCode: 500, Type: "label"}
                        }</span>
                        <span class="cov0" title="0">userResource.Labels = l
                        return nil</span>
                })
                <span class="cov0" title="0">fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                        ts, err := m.getTrainingSets(user.TrainingSets())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal error", err)
                                return &amp;FetchError{StatusCode: 500, Type: "training set"}
                        }</span>
                        <span class="cov0" title="0">userResource.TrainingSets = ts
                        return nil</span>
                })
                <span class="cov0" title="0">fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                        s, err := m.getSources(user.Sources())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal error", err)
                                return &amp;FetchError{StatusCode: 500, Type: "source"}
                        }</span>
                        <span class="cov0" title="0">userResource.Sources = s
                        return nil</span>
                })
                <span class="cov0" title="0">if err := fetchGroup.Wait(); err != nil </span><span class="cov0" title="0">{
                        c.JSON(err.(*FetchError).StatusCode, err.Error())
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, userResource)</span>
        case "models":<span class="cov0" title="0">
                model, err := m.client.GetModel(context.Background(), c.Param("resource"))
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "model"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">modelResource := &amp;ModelResource{
                        Name:        model.Name(),
                        Type:        "Model",
                        Description: model.Description(),
                }
                fetchGroup := new(errgroup.Group)
                fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                        f, err := m.getFeatures(model.Features())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal error", err)
                                return &amp;FetchError{StatusCode: 500, Type: "feature"}
                        }</span>
                        <span class="cov0" title="0">modelResource.Features = f
                        return nil</span>
                })
                <span class="cov0" title="0">fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                        l, err := m.getLabels(model.Labels())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal error", err)
                                return &amp;FetchError{StatusCode: 500, Type: "label"}
                        }</span>
                        <span class="cov0" title="0">modelResource.Labels = l
                        return nil</span>
                })
                <span class="cov0" title="0">fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                        ts, err := m.getTrainingSets(model.TrainingSets())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal error", err)
                                return &amp;FetchError{StatusCode: 500, Type: "training set"}
                        }</span>
                        <span class="cov0" title="0">modelResource.TrainingSets = ts
                        return nil</span>
                })
                <span class="cov0" title="0">if err := fetchGroup.Wait(); err != nil </span><span class="cov0" title="0">{
                        c.JSON(err.(*FetchError).StatusCode, err.Error())
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, modelResource)</span>
        case "providers":<span class="cov0" title="0">
                provider, err := m.client.GetProvider(context.Background(), c.Param("resource"))
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "provider"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">providerResource := &amp;ProviderResource{
                        Name:         provider.Name(),
                        Type:         "Provider",
                        Description:  provider.Description(),
                        ProviderType: provider.Type(),
                        Software:     provider.Software(),
                        Team:         provider.Team(),
                }
                fetchGroup := new(errgroup.Group)
                fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                        f, err := m.getFeatures(provider.Features())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal error", err)
                                return &amp;FetchError{StatusCode: 500, Type: "feature"}
                        }</span>
                        <span class="cov0" title="0">providerResource.Features = f
                        return nil</span>
                })
                <span class="cov0" title="0">fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                        l, err := m.getLabels(provider.Labels())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal error", err)
                                return &amp;FetchError{StatusCode: 500, Type: "label"}
                        }</span>
                        <span class="cov0" title="0">providerResource.Labels = l
                        return nil</span>
                })
                <span class="cov0" title="0">fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                        ts, err := m.getTrainingSets(provider.TrainingSets())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal error", err)
                                return &amp;FetchError{StatusCode: 500, Type: "training set"}
                        }</span>
                        <span class="cov0" title="0">providerResource.TrainingSets = ts
                        return nil</span>
                })
                <span class="cov0" title="0">fetchGroup.Go(func() error </span><span class="cov0" title="0">{
                        s, err := m.getSources(provider.Sources())
                        if err != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(err.Error(), "Internal error", err)
                                return &amp;FetchError{StatusCode: 500, Type: "source"}
                        }</span>
                        <span class="cov0" title="0">providerResource.Sources = s
                        return nil</span>
                })
                <span class="cov0" title="0">if err := fetchGroup.Wait(); err != nil </span><span class="cov0" title="0">{
                        c.JSON(err.(*FetchError).StatusCode, err.Error())
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, providerResource)</span>
        }
}

func (m *MetadataServer) GetMetadataList(c *gin.Context) <span class="cov0" title="0">{

        switch c.Param("type") </span>{
        case "features":<span class="cov0" title="0">
                features, err := m.client.ListFeatures(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "features"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">featureList := make([]FeatureResource, len(features))
                for i, feature := range features </span><span class="cov0" title="0">{
                        variantList, fetchError := m.readFromFeature(feature, false)
                        if fetchError != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(fetchError.Error())
                                c.JSON(fetchError.StatusCode, fetchError.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">featureList[i] = FeatureResource{
                                AllVariants:    feature.Variants(),
                                Type:           "Feature",
                                DefaultVariant: feature.DefaultVariant(),
                                Name:           feature.Name(),
                                Variants:       variantList,
                        }</span>
                }
                <span class="cov0" title="0">c.JSON(http.StatusOK, featureList)</span>
        case "training-sets":<span class="cov0" title="0">
                trainingSets, err := m.client.ListTrainingSets(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "training sets"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">trainingSetList := make([]TrainingSetResource, len(trainingSets))
                for i, trainingSet := range trainingSets </span><span class="cov0" title="0">{
                        variantList, fetchError := m.readFromTrainingSet(trainingSet, false)
                        if fetchError != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(fetchError.Error())
                                c.JSON(fetchError.StatusCode, fetchError.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">trainingSetList[i] = TrainingSetResource{
                                AllVariants:    trainingSet.Variants(),
                                Type:           "TrainingSet",
                                DefaultVariant: trainingSet.DefaultVariant(),
                                Name:           trainingSet.Name(),
                                Variants:       variantList,
                        }</span>
                }
                <span class="cov0" title="0">c.JSON(http.StatusOK, trainingSetList)</span>
        case "primary-data":<span class="cov0" title="0">
                sources, err := m.client.ListSources(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "sources"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">sourceList := make([]SourceResource, len(sources))
                for i, source := range sources </span><span class="cov0" title="0">{
                        variantList, fetchError := m.readFromSource(source, false)
                        if fetchError != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(fetchError.Error())
                                c.JSON(fetchError.StatusCode, fetchError.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">sourceList[i] = SourceResource{
                                AllVariants:    source.Variants(),
                                Type:           "PrimaryData",
                                DefaultVariant: source.DefaultVariant(),
                                Name:           source.Name(),
                                Variants:       variantList,
                        }</span>
                }
                <span class="cov0" title="0">c.JSON(http.StatusOK, sourceList)</span>
        case "labels":<span class="cov0" title="0">
                labels, err := m.client.ListLabels(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "labels"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">labelList := make([]LabelResource, len(labels))

                for i, label := range labels </span><span class="cov0" title="0">{
                        variantList, fetchError := m.readFromLabel(label, false)
                        if fetchError != nil </span><span class="cov0" title="0">{
                                m.logger.Errorw(fetchError.Error())
                                c.JSON(fetchError.StatusCode, fetchError.Error())
                                return
                        }</span>
                        <span class="cov0" title="0">labelList[i] = LabelResource{
                                AllVariants:    label.Variants(),
                                Type:           "Label",
                                DefaultVariant: label.DefaultVariant(),
                                Name:           label.Name(),
                                Variants:       variantList,
                        }</span>
                }
                <span class="cov0" title="0">c.JSON(http.StatusOK, labelList)</span>
        case "entities":<span class="cov0" title="0">
                entities, err := m.client.ListEntities(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "entities"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">entityList := make([]EntityResource, len(entities))
                for i, entity := range entities </span><span class="cov0" title="0">{
                        entityList[i] = EntityResource{
                                Name:        entity.Name(),
                                Type:        "Entity",
                                Description: entity.Description(),
                        }
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, entityList)</span>

        case "models":<span class="cov0" title="0">
                models, err := m.client.ListModels(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "models"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">modelList := make([]ModelResource, len(models))
                for i, model := range models </span><span class="cov0" title="0">{
                        modelList[i] = ModelResource{
                                Name:        model.Name(),
                                Type:        "Model",
                                Description: model.Description(),
                        }
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, modelList)</span>

        case "users":<span class="cov0" title="0">
                users, err := m.client.ListUsers(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "users"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">userList := make([]UserResource, len(users))
                for i, user := range users </span><span class="cov0" title="0">{
                        userList[i] = UserResource{
                                Name: user.Name(),
                                Type: "User",
                        }
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, userList)</span>

        case "providers":<span class="cov0" title="0">
                providers, err := m.client.ListProviders(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        fetchError := &amp;FetchError{StatusCode: 500, Type: "providers"}
                        m.logger.Errorw(fetchError.Error(), "Metadata error", err)
                        c.JSON(fetchError.StatusCode, fetchError.Error())
                        return
                }</span>
                <span class="cov0" title="0">providerList := make([]ProviderResource, len(providers))
                for i, provider := range providers </span><span class="cov0" title="0">{
                        providerList[i] = ProviderResource{
                                Name:         provider.Name(),
                                Type:         "Provider",
                                Description:  provider.Description(),
                                Software:     provider.Software(),
                                Team:         provider.Team(),
                                ProviderType: provider.Type(),
                        }
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusOK, providerList)</span>

        default:<span class="cov0" title="0">
                m.logger.Errorw("Not a valid data type", "Error", c.Param("type"))
                fetchError := &amp;FetchError{StatusCode: 400, Type: c.Param("type")}
                c.JSON(fetchError.StatusCode, fetchError.Error())
                return</span>
        }

}

func (m *MetadataServer) Start(port string) <span class="cov0" title="0">{
        router := gin.Default()
        router.Use(cors.Default())

        router.GET("/:type", m.GetMetadataList)
        router.GET("/:type/:resource", m.GetMetadata)

        router.Run(port)
}</span>

func main() <span class="cov0" title="0">{

        logger := zap.NewExample().Sugar()
        client, err := metadata.NewClient("localhost:8080", logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicw("Failed to connect", "Err", err)
        }</span>

        <span class="cov0" title="0">metadata_server, err := NewMetadataServer(logger, client)
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicw("Failed to create server", "Err", err)
        }</span>
        <span class="cov0" title="0">metadata_port := ":8181"
        metadata_server.Start(metadata_port)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package metadata

import (
        "context"
        "encoding/json"
        "fmt"
        pb "github.com/featureform/serving/metadata/proto"
        "github.com/featureform/serving/metadata/search"
        clientv3 "go.etcd.io/etcd/client/v3"
        "go.uber.org/zap"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
        "google.golang.org/protobuf/proto"
        "io"
        "log"
        "time"
)

const TIME_FORMAT = time.RFC1123

type operation int

const (
        create_op operation = iota
)

type ResourceType string

const (
        FEATURE                ResourceType = "Feature"
        FEATURE_VARIANT                     = "Feature variant"
        LABEL                               = "Label"
        LABEL_VARIANT                       = "Label variant"
        USER                                = "User"
        ENTITY                              = "Entity"
        TRANSFORMATION                      = "Transformation"
        TRANSFORMATION_VARIANT              = "Transformation variant"
        PROVIDER                            = "Provider"
        SOURCE                              = "Source"
        SOURCE_VARIANT                      = "Source variant"
        TRAINING_SET                        = "Training Set"
        TRAINING_SET_VARIANT                = "Training Set variant"
        MODEL                               = "Model"
)

var parentMapping = map[ResourceType]ResourceType{
        FEATURE_VARIANT:        FEATURE,
        LABEL_VARIANT:          LABEL,
        TRANSFORMATION_VARIANT: TRANSFORMATION,
        SOURCE_VARIANT:         SOURCE,
        TRAINING_SET_VARIANT:   TRAINING_SET,
}

type ResourceID struct {
        Name    string
        Variant string
        Type    ResourceType
}

type ResourceStore struct {
        Type ResourceType
        Body string
}

func (id ResourceID) Proto() *pb.NameVariant <span class="cov0" title="0">{
        return &amp;pb.NameVariant{
                Name:    id.Name,
                Variant: id.Variant,
        }
}</span>

func (id ResourceID) Parent() (ResourceID, bool) <span class="cov0" title="0">{
        parentType, has := parentMapping[id.Type]
        if !has </span><span class="cov0" title="0">{
                return ResourceID{}, false
        }</span>
        <span class="cov0" title="0">return ResourceID{
                Name: id.Name,
                Type: parentType,
        }, true</span>
}

type ResourceNotFound struct {
        ID ResourceID
}

func (err *ResourceNotFound) Error() string <span class="cov0" title="0">{
        id := err.ID
        name, variant, t := id.Name, id.Variant, id.Type
        errMsg := fmt.Sprintf("%s Not Found.\nName: %s", t, name)
        if variant != "" </span><span class="cov0" title="0">{
                errMsg += "\nVariant: " + variant
        }</span>
        <span class="cov0" title="0">return errMsg</span>
}

func (err *ResourceNotFound) GRPCStatus() *status.Status <span class="cov0" title="0">{
        return status.New(codes.NotFound, err.Error())
}</span>

type ResourceExists struct {
        ID ResourceID
}

func (err *ResourceExists) Error() string <span class="cov0" title="0">{
        id := err.ID
        name, variant, t := id.Name, id.Variant, id.Type
        errMsg := fmt.Sprintf("%s Exists.\nName: %s", t, name)
        if variant != "" </span><span class="cov0" title="0">{
                errMsg += "\nVariant: " + variant
        }</span>
        <span class="cov0" title="0">return errMsg</span>
}

func (err *ResourceExists) GRPCStatus() *status.Status <span class="cov0" title="0">{
        return status.New(codes.AlreadyExists, err.Error())
}</span>

type Resource interface {
        Notify(ResourceLookup, operation, Resource) error
        ID() ResourceID
        Dependencies(ResourceLookup) (ResourceLookup, error)
        Proto() proto.Message
}

func isDirectDependency(lookup ResourceLookup, dependency, parent Resource) (bool, error) <span class="cov0" title="0">{
        depId := dependency.ID()
        deps, depsErr := parent.Dependencies(lookup)
        if depsErr != nil </span><span class="cov0" title="0">{
                return false, depsErr
        }</span>
        <span class="cov0" title="0">return deps.Has(depId)</span>
}

type ResourceLookup interface {
        Lookup(ResourceID) (Resource, error)
        Has(ResourceID) (bool, error)
        Set(ResourceID, Resource) error
        Submap([]ResourceID) (ResourceLookup, error)
        ListForType(ResourceType) ([]Resource, error)
        List() ([]Resource, error)
}

type TypeSenseWrapper struct {
        Searcher search.Searcher
        ResourceLookup
}

func (wrapper TypeSenseWrapper) Set(id ResourceID, res Resource) error <span class="cov0" title="0">{
        if err := wrapper.ResourceLookup.Set(id, res); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">doc := search.ResourceDoc{
                Name:    id.Name,
                Type:    string(id.Type),
                Variant: id.Variant,
        }
        return wrapper.Searcher.Upsert(doc)</span>
}

type localResourceLookup map[ResourceID]Resource

func (lookup localResourceLookup) Lookup(id ResourceID) (Resource, error) <span class="cov0" title="0">{
        res, has := lookup[id]
        if !has </span><span class="cov0" title="0">{
                return nil, &amp;ResourceNotFound{id}
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}

func (lookup localResourceLookup) Has(id ResourceID) (bool, error) <span class="cov0" title="0">{
        _, has := lookup[id]
        return has, nil
}</span>

func (lookup localResourceLookup) Set(id ResourceID, res Resource) error <span class="cov0" title="0">{
        lookup[id] = res
        return nil
}</span>

func (lookup localResourceLookup) Submap(ids []ResourceID) (ResourceLookup, error) <span class="cov0" title="0">{
        resources := make(localResourceLookup, len(ids))
        for _, id := range ids </span><span class="cov0" title="0">{
                resource, has := lookup[id]
                if !has </span><span class="cov0" title="0">{
                        return nil, &amp;ResourceNotFound{id}
                }</span>
                <span class="cov0" title="0">resources[id] = resource</span>
        }
        <span class="cov0" title="0">return resources, nil</span>
}

func (lookup localResourceLookup) ListForType(t ResourceType) ([]Resource, error) <span class="cov0" title="0">{
        resources := make([]Resource, 0)
        for id, res := range lookup </span><span class="cov0" title="0">{
                if id.Type == t </span><span class="cov0" title="0">{
                        resources = append(resources, res)
                }</span>
        }
        <span class="cov0" title="0">return resources, nil</span>
}

func (lookup localResourceLookup) List() ([]Resource, error) <span class="cov0" title="0">{
        resources := make([]Resource, 0, len(lookup))
        for _, res := range lookup </span><span class="cov0" title="0">{
                resources = append(resources, res)
        }</span>
        <span class="cov0" title="0">return resources, nil</span>
}

//Create Resource Lookup Using ETCD
type etcdResourceLookup struct {
        Etcd *clientv3.Client
}

type etcdStorage struct {
        Type    ResourceType
        Message []byte
}

func (lookup etcdResourceLookup) findType(t ResourceType) (Resource, error) <span class="cov8" title="1">{
        var resource Resource
        switch t </span>{
        case FEATURE:<span class="cov8" title="1">
                resource = &amp;featureResource{&amp;pb.Feature{}}
                break</span>
        case FEATURE_VARIANT:<span class="cov0" title="0">
                resource = &amp;featureVariantResource{&amp;pb.FeatureVariant{}}
                break</span>
        case LABEL:<span class="cov0" title="0">
                resource = &amp;labelResource{&amp;pb.Label{}}
                break</span>
        case LABEL_VARIANT:<span class="cov0" title="0">
                resource = &amp;labelVariantResource{&amp;pb.LabelVariant{}}
                break</span>
        case USER:<span class="cov0" title="0">
                resource = &amp;userResource{&amp;pb.User{}}
                break</span>
        case ENTITY:<span class="cov0" title="0">
                resource = &amp;entityResource{&amp;pb.Entity{}}
                break</span>
                // Transformation Not Included
        //case TRANSFORMATION:
        //        resource = &amp;transformation{&amp;pb.FeatureVariant{}}
        //        break
        //case TRANSFORMATION_VARIANT :
        //        resource = &amp;featureVariantResource{&amp;pb.FeatureVariant{}}
        //        break
        case PROVIDER:<span class="cov0" title="0">
                resource = &amp;providerResource{&amp;pb.Provider{}}
                break</span>
        case SOURCE:<span class="cov0" title="0">
                resource = &amp;sourceResource{&amp;pb.Source{}}
                break</span>
        case SOURCE_VARIANT:<span class="cov0" title="0">
                resource = &amp;sourceVariantResource{&amp;pb.SourceVariant{}}
                break</span>
        case TRAINING_SET:<span class="cov0" title="0">
                resource = &amp;trainingSetResource{&amp;pb.TrainingSet{}}
                break</span>
        case TRAINING_SET_VARIANT:<span class="cov0" title="0">
                resource = &amp;trainingSetVariantResource{&amp;pb.TrainingSetVariant{}}
                break</span>
        case MODEL:<span class="cov0" title="0">
                resource = &amp;modelResource{&amp;pb.Model{}}
                break</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("Invalid Type\n")</span>
        }
        <span class="cov8" title="1">return resource, nil</span>
}

func (lookup etcdResourceLookup) Lookup(id ResourceID) (Resource, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), time.Second*1)
        name := id.Name
        resp, err := lookup.Etcd.Get(ctx, name)
        cancel()
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;ResourceNotFound{id}
        }</span>
        <span class="cov8" title="1">var msg etcdStorage
        value := resp.Kvs[0].Value
        if err := json.Unmarshal(value, &amp;msg); err != nil </span><span class="cov0" title="0">{
                log.Fatalln("Failed To Parse Resource", err)
        }</span>
        <span class="cov8" title="1">resource, err := lookup.findType(msg.Type)
        if err := proto.Unmarshal(msg.Message, resource.Proto()); err != nil </span><span class="cov0" title="0">{
                log.Fatalln("Failed to parse address book:", err)
        }</span>

        <span class="cov8" title="1">return resource, nil</span>
}

func (lookup etcdResourceLookup) Has(id ResourceID) (bool, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5)
        name := id.Name
        resp, err := lookup.Etcd.Get(ctx, name)
        cancel()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">if resp.Count == 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (lookup etcdResourceLookup) Set(id ResourceID, res Resource) error <span class="cov8" title="1">{
        var err error
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">defer lookup.Etcd.Close()

        name := id.Name

        p, _ := proto.Marshal(res.Proto())
        msg := etcdStorage{
                Type:    id.Type,
                Message: p,
        }
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov8" title="1">strmsg, err := json.Marshal(msg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), time.Second*1)
        _, err = lookup.Etcd.Put(ctx, name, string(strmsg))
        cancel()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (lookup etcdResourceLookup) Submap(ids []ResourceID) (ResourceLookup, error) <span class="cov0" title="0">{
        ctx, _ := context.WithTimeout(context.Background(), 5)
        resources := make(localResourceLookup, len(ids))

        for _, id := range ids </span><span class="cov0" title="0">{
                var response []byte
                if resp, err := lookup.Etcd.Do(ctx, clientv3.OpGet(id.Name)); err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;ResourceNotFound{id}
                }</span> else<span class="cov0" title="0"> {
                        response = resp.Get().Kvs[0].Value
                }</span>
                <span class="cov0" title="0">var resource Resource
                if err := proto.Unmarshal(response, resource.Proto()); err != nil </span><span class="cov0" title="0">{
                        log.Fatalln("Failed to parse address book:", err)
                }</span>
                <span class="cov0" title="0">resources[id] = resource</span>
        }

        <span class="cov0" title="0">return resources, nil</span>
}

func (lookup etcdResourceLookup) ListForType(t ResourceType) ([]Resource, error) <span class="cov0" title="0">{
        resources := make([]Resource, 0)
        ctx, cancel := context.WithTimeout(context.Background(), 5)
        resp, err := lookup.Etcd.Get(ctx, "", clientv3.WithPrefix())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cancel()
        for _, res := range resp.Kvs </span><span class="cov0" title="0">{
                var resource Resource
                if err := proto.Unmarshal(res.Value, resource.Proto()); err != nil </span><span class="cov0" title="0">{
                        log.Fatalln("Failed to parse address book:", err)
                }</span>
                <span class="cov0" title="0">if resource.ID().Type == t </span><span class="cov0" title="0">{
                        resources = append(resources, resource)
                }</span>
        }
        <span class="cov0" title="0">return resources, nil</span>
}

func (lookup etcdResourceLookup) List() ([]Resource, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5)
        resp, err := lookup.Etcd.Get(ctx, "", clientv3.WithPrefix())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cancel()
        resources := make([]Resource, 0, resp.Count)
        for _, res := range resp.Kvs </span><span class="cov0" title="0">{
                var resource Resource
                if err := proto.Unmarshal(res.Value, resource.Proto()); err != nil </span><span class="cov0" title="0">{
                        log.Fatalln("Failed to parse address book:", err)
                }</span>
                <span class="cov0" title="0">resources = append(resources, resource)</span>
        }
        <span class="cov0" title="0">return resources, nil</span>
}

type sourceResource struct {
        serialized *pb.Source
}

func (resource *sourceResource) ID() ResourceID <span class="cov0" title="0">{
        return ResourceID{
                Name: resource.serialized.Name,
                Type: SOURCE,
        }
}</span>

func (resource *sourceResource) Dependencies(lookup ResourceLookup) (ResourceLookup, error) <span class="cov0" title="0">{
        name := resource.serialized.Name
        deps := make(localResourceLookup)
        for _, variant := range resource.serialized.Variants </span><span class="cov0" title="0">{
                id := ResourceID{
                        Name:    name,
                        Variant: variant,
                        Type:    SOURCE_VARIANT,
                }
                res, err := lookup.Lookup(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">deps[id] = res</span>
        }
        <span class="cov0" title="0">return deps, nil</span>
}

func (resource *sourceResource) Proto() proto.Message <span class="cov0" title="0">{
        return resource.serialized
}</span>

func (this *sourceResource) Notify(lookup ResourceLookup, op operation, that Resource) error <span class="cov0" title="0">{
        otherId := that.ID()
        isVariant := otherId.Type == SOURCE_VARIANT &amp;&amp; otherId.Name == this.serialized.Name
        if !isVariant </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">this.serialized.Variants = append(this.serialized.Variants, otherId.Variant)
        return nil</span>
}

type sourceVariantResource struct {
        serialized *pb.SourceVariant
}

func (resource *sourceVariantResource) ID() ResourceID <span class="cov0" title="0">{
        return ResourceID{
                Name:    resource.serialized.Name,
                Variant: resource.serialized.Variant,
                Type:    SOURCE_VARIANT,
        }
}</span>

func (resource *sourceVariantResource) Dependencies(lookup ResourceLookup) (ResourceLookup, error) <span class="cov0" title="0">{
        serialized := resource.serialized
        depIds := []ResourceID{
                {
                        Name: serialized.Owner,
                        Type: USER,
                },
                {
                        Name: serialized.Provider,
                        Type: PROVIDER,
                },
                {
                        Name: serialized.Name,
                        Type: SOURCE,
                },
        }
        deps, err := lookup.Submap(depIds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return deps, nil</span>
}

func (resource *sourceVariantResource) Proto() proto.Message <span class="cov0" title="0">{
        return resource.serialized
}</span>

func (this *sourceVariantResource) Notify(lookup ResourceLookup, op operation, that Resource) error <span class="cov0" title="0">{
        id := that.ID()
        t := id.Type
        key := id.Proto()
        serialized := this.serialized
        switch t </span>{
        case TRAINING_SET_VARIANT:<span class="cov0" title="0">
                serialized.Trainingsets = append(serialized.Trainingsets, key)</span>
        case FEATURE_VARIANT:<span class="cov0" title="0">
                serialized.Features = append(serialized.Features, key)</span>
        case LABEL_VARIANT:<span class="cov0" title="0">
                serialized.Labels = append(serialized.Labels, key)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type featureResource struct {
        serialized *pb.Feature
}

func (resource *featureResource) ID() ResourceID <span class="cov0" title="0">{
        return ResourceID{
                Name: resource.serialized.Name,
                Type: FEATURE,
        }
}</span>

func (resource *featureResource) Dependencies(lookup ResourceLookup) (ResourceLookup, error) <span class="cov0" title="0">{
        name := resource.serialized.Name
        deps := make(localResourceLookup)
        for _, variant := range resource.serialized.Variants </span><span class="cov0" title="0">{
                id := ResourceID{
                        Name:    name,
                        Variant: variant,
                        Type:    FEATURE_VARIANT,
                }
                res, err := lookup.Lookup(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">deps[id] = res</span>
        }
        <span class="cov0" title="0">return deps, nil</span>
}

func (resource *featureResource) Proto() proto.Message <span class="cov8" title="1">{
        return resource.serialized
}</span>

func (this *featureResource) Notify(lookup ResourceLookup, op operation, that Resource) error <span class="cov0" title="0">{
        otherId := that.ID()
        isVariant := otherId.Type == FEATURE_VARIANT &amp;&amp; otherId.Name == this.serialized.Name
        if !isVariant </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">this.serialized.Variants = append(this.serialized.Variants, otherId.Variant)
        return nil</span>
}

type featureVariantResource struct {
        serialized *pb.FeatureVariant
}

func (resource *featureVariantResource) ID() ResourceID <span class="cov0" title="0">{
        return ResourceID{
                Name:    resource.serialized.Name,
                Variant: resource.serialized.Variant,
                Type:    FEATURE_VARIANT,
        }
}</span>

func (resource *featureVariantResource) Dependencies(lookup ResourceLookup) (ResourceLookup, error) <span class="cov0" title="0">{
        serialized := resource.serialized
        depIds := []ResourceID{
                {
                        Name:    serialized.Source.Name,
                        Variant: serialized.Source.Variant,
                        Type:    SOURCE_VARIANT,
                },
                {
                        Name: serialized.Entity,
                        Type: ENTITY,
                },
                {
                        Name: serialized.Owner,
                        Type: USER,
                },
                {
                        Name: serialized.Provider,
                        Type: PROVIDER,
                },
                {
                        Name: serialized.Name,
                        Type: FEATURE,
                },
        }
        deps, err := lookup.Submap(depIds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return deps, nil</span>
}

func (resource *featureVariantResource) Proto() proto.Message <span class="cov8" title="1">{
        return resource.serialized
}</span>

func (this *featureVariantResource) Notify(lookup ResourceLookup, op operation, that Resource) error <span class="cov0" title="0">{
        id := that.ID()
        releventOp := op == create_op &amp;&amp; id.Type == TRAINING_SET_VARIANT
        if !releventOp </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">key := id.Proto()
        this.serialized.Trainingsets = append(this.serialized.Trainingsets, key)
        return nil</span>
}

type labelResource struct {
        serialized *pb.Label
}

func (resource *labelResource) ID() ResourceID <span class="cov0" title="0">{
        return ResourceID{
                Name: resource.serialized.Name,
                Type: LABEL,
        }
}</span>

func (resource *labelResource) Dependencies(lookup ResourceLookup) (ResourceLookup, error) <span class="cov0" title="0">{
        name := resource.serialized.Name
        deps := make(localResourceLookup)
        for _, variant := range resource.serialized.Variants </span><span class="cov0" title="0">{
                id := ResourceID{
                        Name:    name,
                        Variant: variant,
                        Type:    LABEL_VARIANT,
                }
                res, err := lookup.Lookup(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">deps[id] = res</span>
        }
        <span class="cov0" title="0">return deps, nil</span>
}

func (resource *labelResource) Proto() proto.Message <span class="cov0" title="0">{
        return resource.serialized
}</span>

func (this *labelResource) Notify(lookup ResourceLookup, op operation, that Resource) error <span class="cov0" title="0">{
        otherId := that.ID()
        isVariant := otherId.Type == LABEL_VARIANT &amp;&amp; otherId.Name == this.serialized.Name
        if !isVariant </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">this.serialized.Variants = append(this.serialized.Variants, otherId.Variant)
        return nil</span>
}

type labelVariantResource struct {
        serialized *pb.LabelVariant
}

func (resource *labelVariantResource) ID() ResourceID <span class="cov0" title="0">{
        return ResourceID{
                Name:    resource.serialized.Name,
                Variant: resource.serialized.Variant,
                Type:    LABEL_VARIANT,
        }
}</span>

func (resource *labelVariantResource) Dependencies(lookup ResourceLookup) (ResourceLookup, error) <span class="cov0" title="0">{
        serialized := resource.serialized
        depIds := []ResourceID{
                {
                        Name:    serialized.Source.Name,
                        Variant: serialized.Source.Variant,
                        Type:    SOURCE_VARIANT,
                },
                {
                        Name: serialized.Entity,
                        Type: ENTITY,
                },
                {
                        Name: serialized.Owner,
                        Type: USER,
                },
                {
                        Name: serialized.Provider,
                        Type: PROVIDER,
                },
                {
                        Name: serialized.Name,
                        Type: LABEL,
                },
        }
        deps, err := lookup.Submap(depIds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return deps, nil</span>
}

func (resource *labelVariantResource) Proto() proto.Message <span class="cov0" title="0">{
        return resource.serialized
}</span>

func (this *labelVariantResource) Notify(lookup ResourceLookup, op operation, that Resource) error <span class="cov0" title="0">{
        id := that.ID()
        releventOp := op == create_op &amp;&amp; id.Type == TRAINING_SET_VARIANT
        if !releventOp </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">key := id.Proto()
        this.serialized.Trainingsets = append(this.serialized.Trainingsets, key)
        return nil</span>
}

type trainingSetResource struct {
        serialized *pb.TrainingSet
}

func (resource *trainingSetResource) ID() ResourceID <span class="cov0" title="0">{
        return ResourceID{
                Name: resource.serialized.Name,
                Type: TRAINING_SET,
        }
}</span>

func (resource *trainingSetResource) Dependencies(lookup ResourceLookup) (ResourceLookup, error) <span class="cov0" title="0">{
        name := resource.serialized.Name
        deps := make(localResourceLookup)
        for _, variant := range resource.serialized.Variants </span><span class="cov0" title="0">{
                id := ResourceID{
                        Name:    name,
                        Variant: variant,
                        Type:    TRAINING_SET_VARIANT,
                }
                res, err := lookup.Lookup(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">deps[id] = res</span>
        }
        <span class="cov0" title="0">return deps, nil</span>
}

func (resource *trainingSetResource) Proto() proto.Message <span class="cov0" title="0">{
        return resource.serialized
}</span>

func (this *trainingSetResource) Notify(lookup ResourceLookup, op operation, that Resource) error <span class="cov0" title="0">{
        otherId := that.ID()
        isVariant := otherId.Type == TRAINING_SET_VARIANT &amp;&amp; otherId.Name == this.serialized.Name
        if !isVariant </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">this.serialized.Variants = append(this.serialized.Variants, otherId.Variant)
        return nil</span>
}

type trainingSetVariantResource struct {
        serialized *pb.TrainingSetVariant
}

func (resource *trainingSetVariantResource) ID() ResourceID <span class="cov0" title="0">{
        return ResourceID{
                Name:    resource.serialized.Name,
                Variant: resource.serialized.Variant,
                Type:    TRAINING_SET_VARIANT,
        }
}</span>

func (resource *trainingSetVariantResource) Dependencies(lookup ResourceLookup) (ResourceLookup, error) <span class="cov0" title="0">{
        serialized := resource.serialized
        depIds := []ResourceID{
                {
                        Name: serialized.Owner,
                        Type: USER,
                },
                {
                        Name: serialized.Provider,
                        Type: PROVIDER,
                },
                {
                        Name:    serialized.Label.Name,
                        Variant: serialized.Label.Variant,
                        Type:    LABEL_VARIANT,
                },
                {
                        Name: serialized.Name,
                        Type: TRAINING_SET,
                },
        }
        for _, feature := range serialized.Features </span><span class="cov0" title="0">{
                depIds = append(depIds, ResourceID{
                        Name:    feature.Name,
                        Variant: feature.Variant,
                        Type:    FEATURE_VARIANT,
                })
        }</span>
        <span class="cov0" title="0">deps, err := lookup.Submap(depIds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return deps, nil</span>
}

func (resource *trainingSetVariantResource) Proto() proto.Message <span class="cov0" title="0">{
        return resource.serialized
}</span>

func (this *trainingSetVariantResource) Notify(lookup ResourceLookup, op operation, that Resource) error <span class="cov0" title="0">{
        return nil
}</span>

type modelResource struct {
        serialized *pb.Model
}

func (resource *modelResource) ID() ResourceID <span class="cov0" title="0">{
        return ResourceID{
                Name: resource.serialized.Name,
                Type: MODEL,
        }
}</span>

func (resource *modelResource) Dependencies(lookup ResourceLookup) (ResourceLookup, error) <span class="cov0" title="0">{
        serialized := resource.serialized
        depIds := make([]ResourceID, 0)
        for _, feature := range serialized.Features </span><span class="cov0" title="0">{
                depIds = append(depIds, ResourceID{
                        Name:    feature.Name,
                        Variant: feature.Variant,
                        Type:    FEATURE_VARIANT,
                })
        }</span>
        <span class="cov0" title="0">for _, label := range serialized.Labels </span><span class="cov0" title="0">{
                depIds = append(depIds, ResourceID{
                        Name:    label.Name,
                        Variant: label.Variant,
                        Type:    LABEL_VARIANT,
                })
        }</span>
        <span class="cov0" title="0">for _, ts := range serialized.Trainingsets </span><span class="cov0" title="0">{
                depIds = append(depIds, ResourceID{
                        Name:    ts.Name,
                        Variant: ts.Variant,
                        Type:    TRAINING_SET_VARIANT,
                })
        }</span>
        <span class="cov0" title="0">deps, err := lookup.Submap(depIds)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return deps, nil</span>
}

func (resource *modelResource) Proto() proto.Message <span class="cov0" title="0">{
        return resource.serialized
}</span>

func (this *modelResource) Notify(lookup ResourceLookup, op operation, that Resource) error <span class="cov0" title="0">{
        return nil
}</span>

type userResource struct {
        serialized *pb.User
}

func (resource *userResource) ID() ResourceID <span class="cov0" title="0">{
        return ResourceID{
                Name: resource.serialized.Name,
                Type: USER,
        }
}</span>

func (resource *userResource) Dependencies(lookup ResourceLookup) (ResourceLookup, error) <span class="cov0" title="0">{
        return make(localResourceLookup), nil
}</span>

func (resource *userResource) Proto() proto.Message <span class="cov0" title="0">{
        return resource.serialized
}</span>

func (this *userResource) Notify(lookup ResourceLookup, op operation, that Resource) error <span class="cov0" title="0">{
        userId := this.ID()
        deps, depsErr := that.Dependencies(lookup)
        if depsErr != nil </span><span class="cov0" title="0">{
                return depsErr
        }</span>
        <span class="cov0" title="0">_, lookupErr := deps.Lookup(userId)
        if lookupErr != nil </span><span class="cov0" title="0">{
                return lookupErr
        }</span>
        <span class="cov0" title="0">id := that.ID()
        key := id.Proto()
        t := id.Type
        serialized := this.serialized
        switch t </span>{
        case TRAINING_SET_VARIANT:<span class="cov0" title="0">
                serialized.Trainingsets = append(serialized.Trainingsets, key)</span>
        case FEATURE_VARIANT:<span class="cov0" title="0">
                serialized.Features = append(serialized.Features, key)</span>
        case LABEL_VARIANT:<span class="cov0" title="0">
                serialized.Labels = append(serialized.Labels, key)</span>
        case SOURCE_VARIANT:<span class="cov0" title="0">
                serialized.Sources = append(serialized.Sources, key)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type providerResource struct {
        serialized *pb.Provider
}

func (resource *providerResource) ID() ResourceID <span class="cov0" title="0">{
        return ResourceID{
                Name: resource.serialized.Name,
                Type: PROVIDER,
        }
}</span>

func (resource *providerResource) Dependencies(lookup ResourceLookup) (ResourceLookup, error) <span class="cov0" title="0">{
        return make(localResourceLookup), nil
}</span>

func (resource *providerResource) Proto() proto.Message <span class="cov0" title="0">{
        return resource.serialized
}</span>

func (this *providerResource) Notify(lookup ResourceLookup, op operation, that Resource) error <span class="cov0" title="0">{
        if isDep, err := isDirectDependency(lookup, this, that); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if !isDep </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">id := that.ID()
        key := id.Proto()
        t := id.Type
        serialized := this.serialized
        switch t </span>{
        case SOURCE_VARIANT:<span class="cov0" title="0">
                serialized.Sources = append(serialized.Sources, key)</span>
        case FEATURE_VARIANT:<span class="cov0" title="0">
                serialized.Features = append(serialized.Features, key)</span>
        case TRAINING_SET_VARIANT:<span class="cov0" title="0">
                serialized.Trainingsets = append(serialized.Trainingsets, key)</span>
        case LABEL_VARIANT:<span class="cov0" title="0">
                serialized.Labels = append(serialized.Labels, key)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type entityResource struct {
        serialized *pb.Entity
}

func (resource *entityResource) ID() ResourceID <span class="cov0" title="0">{
        return ResourceID{
                Name: resource.serialized.Name,
                Type: ENTITY,
        }
}</span>

func (resource *entityResource) Dependencies(lookup ResourceLookup) (ResourceLookup, error) <span class="cov0" title="0">{
        return make(localResourceLookup), nil
}</span>

func (resource *entityResource) Proto() proto.Message <span class="cov0" title="0">{
        return resource.serialized
}</span>

func (this *entityResource) Notify(lookup ResourceLookup, op operation, that Resource) error <span class="cov0" title="0">{
        if isDep, err := isDirectDependency(lookup, this, that); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov0" title="0"> if !isDep </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">id := that.ID()
        key := id.Proto()
        t := id.Type
        serialized := this.serialized
        switch t </span>{
        case TRAINING_SET_VARIANT:<span class="cov0" title="0">
                serialized.Trainingsets = append(serialized.Trainingsets, key)</span>
        case FEATURE_VARIANT:<span class="cov0" title="0">
                serialized.Features = append(serialized.Features, key)</span>
        case LABEL_VARIANT:<span class="cov0" title="0">
                serialized.Labels = append(serialized.Labels, key)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type MetadataServer struct {
        lookup ResourceLookup
        Logger *zap.SugaredLogger
        pb.UnimplementedMetadataServer
}

func NewMetadataServer(server *Config) (*MetadataServer, error) <span class="cov0" title="0">{
        server.Logger.Debug("Creating new metadata server")
        var lookup ResourceLookup = make(localResourceLookup)
        if server.TypeSenseParams != nil </span><span class="cov0" title="0">{
                searcher, errInitializeSearch := search.NewTypesenseSearch(server.TypeSenseParams)
                if errInitializeSearch != nil </span><span class="cov0" title="0">{
                        return nil, errInitializeSearch
                }</span>
                <span class="cov0" title="0">lookup = &amp;TypeSenseWrapper{
                        Searcher:       searcher,
                        ResourceLookup: lookup,
                }</span>
        }
        <span class="cov0" title="0">return &amp;MetadataServer{
                lookup: lookup,
                Logger: server.Logger,
        }, nil</span>
}

type Config struct {
        Logger          *zap.SugaredLogger
        TypeSenseParams *search.TypeSenseParams
}

func (serv *MetadataServer) ListFeatures(_ *pb.Empty, stream pb.Metadata_ListFeaturesServer) error <span class="cov0" title="0">{
        return serv.genericList(FEATURE, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.Feature))
        }</span>)
}

func (serv *MetadataServer) CreateFeatureVariant(ctx context.Context, variant *pb.FeatureVariant) (*pb.Empty, error) <span class="cov0" title="0">{
        variant.Created = time.Now().Format(TIME_FORMAT)
        return serv.genericCreate(ctx, &amp;featureVariantResource{variant}, func(name, variant string) Resource </span><span class="cov0" title="0">{
                return &amp;featureResource{
                        &amp;pb.Feature{
                                Name:           name,
                                DefaultVariant: variant,
                                // This will be set when the change is propogated to dependencies.
                                Variants: []string{},
                        },
                }
        }</span>)
}

func (serv *MetadataServer) GetFeatures(stream pb.Metadata_GetFeaturesServer) error <span class="cov0" title="0">{
        return serv.genericGet(stream, FEATURE, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.Feature))
        }</span>)
}

func (serv *MetadataServer) GetFeatureVariants(stream pb.Metadata_GetFeatureVariantsServer) error <span class="cov0" title="0">{
        return serv.genericGet(stream, FEATURE_VARIANT, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.FeatureVariant))
        }</span>)
}

func (serv *MetadataServer) ListLabels(_ *pb.Empty, stream pb.Metadata_ListLabelsServer) error <span class="cov0" title="0">{
        return serv.genericList(LABEL, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.Label))
        }</span>)
}

func (serv *MetadataServer) CreateLabelVariant(ctx context.Context, variant *pb.LabelVariant) (*pb.Empty, error) <span class="cov0" title="0">{
        variant.Created = time.Now().Format(TIME_FORMAT)
        return serv.genericCreate(ctx, &amp;labelVariantResource{variant}, func(name, variant string) Resource </span><span class="cov0" title="0">{
                return &amp;labelResource{
                        &amp;pb.Label{
                                Name:           name,
                                DefaultVariant: variant,
                                // This will be set when the change is propogated to dependencies.
                                Variants: []string{},
                        },
                }
        }</span>)
}

func (serv *MetadataServer) GetLabels(stream pb.Metadata_GetLabelsServer) error <span class="cov0" title="0">{
        return serv.genericGet(stream, LABEL, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.Label))
        }</span>)
}

func (serv *MetadataServer) GetLabelVariants(stream pb.Metadata_GetLabelVariantsServer) error <span class="cov0" title="0">{
        return serv.genericGet(stream, LABEL_VARIANT, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.LabelVariant))
        }</span>)
}

func (serv *MetadataServer) ListTrainingSets(_ *pb.Empty, stream pb.Metadata_ListTrainingSetsServer) error <span class="cov0" title="0">{
        return serv.genericList(TRAINING_SET, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.TrainingSet))
        }</span>)
}

func (serv *MetadataServer) CreateTrainingSetVariant(ctx context.Context, variant *pb.TrainingSetVariant) (*pb.Empty, error) <span class="cov0" title="0">{
        variant.Created = time.Now().Format(TIME_FORMAT)
        return serv.genericCreate(ctx, &amp;trainingSetVariantResource{variant}, func(name, variant string) Resource </span><span class="cov0" title="0">{
                return &amp;trainingSetResource{
                        &amp;pb.TrainingSet{
                                Name:           name,
                                DefaultVariant: variant,
                                // This will be set when the change is propogated to dependencies.
                                Variants: []string{},
                        },
                }
        }</span>)
}

func (serv *MetadataServer) GetTrainingSets(stream pb.Metadata_GetTrainingSetsServer) error <span class="cov0" title="0">{
        return serv.genericGet(stream, TRAINING_SET, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.TrainingSet))
        }</span>)
}

func (serv *MetadataServer) GetTrainingSetVariants(stream pb.Metadata_GetTrainingSetVariantsServer) error <span class="cov0" title="0">{
        return serv.genericGet(stream, TRAINING_SET_VARIANT, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.TrainingSetVariant))
        }</span>)
}

func (serv *MetadataServer) ListSources(_ *pb.Empty, stream pb.Metadata_ListSourcesServer) error <span class="cov0" title="0">{
        return serv.genericList(SOURCE, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.Source))
        }</span>)
}

func (serv *MetadataServer) CreateSourceVariant(ctx context.Context, variant *pb.SourceVariant) (*pb.Empty, error) <span class="cov0" title="0">{
        variant.Created = time.Now().Format(TIME_FORMAT)
        return serv.genericCreate(ctx, &amp;sourceVariantResource{variant}, func(name, variant string) Resource </span><span class="cov0" title="0">{
                return &amp;sourceResource{
                        &amp;pb.Source{
                                Name:           name,
                                DefaultVariant: variant,
                                // This will be set when the change is propogated to dependencies.
                                Variants: []string{},
                        },
                }
        }</span>)
}

func (serv *MetadataServer) GetSources(stream pb.Metadata_GetSourcesServer) error <span class="cov0" title="0">{
        return serv.genericGet(stream, SOURCE, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.Source))
        }</span>)
}

func (serv *MetadataServer) GetSourceVariants(stream pb.Metadata_GetSourceVariantsServer) error <span class="cov0" title="0">{
        return serv.genericGet(stream, SOURCE_VARIANT, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.SourceVariant))
        }</span>)
}

func (serv *MetadataServer) ListUsers(_ *pb.Empty, stream pb.Metadata_ListUsersServer) error <span class="cov0" title="0">{
        return serv.genericList(USER, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.User))
        }</span>)
}

func (serv *MetadataServer) CreateUser(ctx context.Context, user *pb.User) (*pb.Empty, error) <span class="cov0" title="0">{
        return serv.genericCreate(ctx, &amp;userResource{user}, nil)
}</span>

func (serv *MetadataServer) GetUsers(stream pb.Metadata_GetUsersServer) error <span class="cov0" title="0">{
        return serv.genericGet(stream, USER, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.User))
        }</span>)
}

func (serv *MetadataServer) ListProviders(_ *pb.Empty, stream pb.Metadata_ListProvidersServer) error <span class="cov0" title="0">{
        return serv.genericList(PROVIDER, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.Provider))
        }</span>)
}

func (serv *MetadataServer) CreateProvider(ctx context.Context, provider *pb.Provider) (*pb.Empty, error) <span class="cov0" title="0">{
        return serv.genericCreate(ctx, &amp;providerResource{provider}, nil)
}</span>

func (serv *MetadataServer) GetProviders(stream pb.Metadata_GetProvidersServer) error <span class="cov0" title="0">{
        return serv.genericGet(stream, PROVIDER, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.Provider))
        }</span>)
}

func (serv *MetadataServer) ListEntities(_ *pb.Empty, stream pb.Metadata_ListEntitiesServer) error <span class="cov0" title="0">{
        return serv.genericList(ENTITY, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.Entity))
        }</span>)
}

func (serv *MetadataServer) CreateEntity(ctx context.Context, entity *pb.Entity) (*pb.Empty, error) <span class="cov0" title="0">{
        return serv.genericCreate(ctx, &amp;entityResource{entity}, nil)
}</span>

func (serv *MetadataServer) GetEntities(stream pb.Metadata_GetEntitiesServer) error <span class="cov0" title="0">{
        return serv.genericGet(stream, ENTITY, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.Entity))
        }</span>)
}

func (serv *MetadataServer) ListModels(_ *pb.Empty, stream pb.Metadata_ListModelsServer) error <span class="cov0" title="0">{
        return serv.genericList(MODEL, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.Model))
        }</span>)
}

func (serv *MetadataServer) CreateModel(ctx context.Context, model *pb.Model) (*pb.Empty, error) <span class="cov0" title="0">{
        return serv.genericCreate(ctx, &amp;modelResource{model}, nil)
}</span>

func (serv *MetadataServer) GetModels(stream pb.Metadata_GetModelsServer) error <span class="cov0" title="0">{
        return serv.genericGet(stream, MODEL, func(msg proto.Message) error </span><span class="cov0" title="0">{
                return stream.Send(msg.(*pb.Model))
        }</span>)
}

type nameStream interface {
        Recv() (*pb.Name, error)
}

type variantStream interface {
        Recv() (*pb.NameVariant, error)
}

type sendFn func(proto.Message) error

type initParentFn func(name, variant string) Resource

func (serv *MetadataServer) genericCreate(ctx context.Context, res Resource, init initParentFn) (*pb.Empty, error) <span class="cov0" title="0">{
        id := res.ID()
        if has, err := serv.lookup.Has(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span> else<span class="cov0" title="0"> if has </span><span class="cov0" title="0">{
                return nil, &amp;ResourceExists{id}
        }</span>
        <span class="cov0" title="0">if err := serv.lookup.Set(id, res); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">parentId, hasParent := id.Parent()
        if hasParent </span><span class="cov0" title="0">{
                if parentExists, err := serv.lookup.Has(parentId); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span> else<span class="cov0" title="0"> if !parentExists </span><span class="cov0" title="0">{
                        parent := init(id.Name, id.Variant)
                        if err := serv.lookup.Set(parentId, parent); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }
        <span class="cov0" title="0">if err := serv.propogateChange(res); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;pb.Empty{}, nil</span>
}

func (serv *MetadataServer) propogateChange(newRes Resource) error <span class="cov0" title="0">{
        visited := make(map[ResourceID]struct{})
        // We have to make it a var so that the anonymous function can call itself.
        var propogateChange func(parent Resource) error
        propogateChange = func(parent Resource) error </span><span class="cov0" title="0">{
                deps, err := parent.Dependencies(serv.lookup)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">depList, err := deps.List()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, res := range depList </span><span class="cov0" title="0">{
                        id := res.ID()
                        if _, has := visited[id]; has </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">visited[id] = struct{}{}
                        if err := res.Notify(serv.lookup, create_op, newRes); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := propogateChange(res); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return propogateChange(newRes)</span>
}

func (serv *MetadataServer) genericGet(stream interface{}, t ResourceType, send sendFn) error <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                var recvErr error
                var id ResourceID
                switch casted := stream.(type) </span>{
                case nameStream:<span class="cov0" title="0">
                        req, err := casted.Recv()
                        recvErr = err
                        id = ResourceID{
                                Name: req.GetName(),
                                Type: t,
                        }</span>
                case variantStream:<span class="cov0" title="0">
                        req, err := casted.Recv()
                        recvErr = err
                        id = ResourceID{
                                Name:    req.GetName(),
                                Variant: req.GetVariant(),
                                Type:    t,
                        }</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("Invalid Stream for Get: %T", casted)</span>
                }
                <span class="cov0" title="0">if recvErr == io.EOF </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if recvErr != nil </span><span class="cov0" title="0">{
                        return recvErr
                }</span>
                <span class="cov0" title="0">resource, err := serv.lookup.Lookup(id)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">serialized := resource.Proto()
                if err := send(serialized); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
}

func (serv *MetadataServer) genericList(t ResourceType, send sendFn) error <span class="cov0" title="0">{
        resources, err := serv.lookup.ListForType(t)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, res := range resources </span><span class="cov0" title="0">{
                serialized := res.Proto()
                if err := send(serialized); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.27.1
//         protoc        v3.19.4
// source: metadata/proto/metadata.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Name struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *Name) Reset() <span class="cov0" title="0">{
        *x = Name{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Name) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Name) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Name) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Name.ProtoReflect.Descriptor instead.
func (*Name) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Name) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type NameVariant struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Variant string `protobuf:"bytes,2,opt,name=variant,proto3" json:"variant,omitempty"`
}

func (x *NameVariant) Reset() <span class="cov0" title="0">{
        *x = NameVariant{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *NameVariant) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*NameVariant) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *NameVariant) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use NameVariant.ProtoReflect.Descriptor instead.
func (*NameVariant) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{1}
}</span>

func (x *NameVariant) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *NameVariant) GetVariant() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Variant
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Empty struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *Empty) Reset() <span class="cov0" title="0">{
        *x = Empty{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Empty) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Empty) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Empty) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Empty.ProtoReflect.Descriptor instead.
func (*Empty) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{2}
}</span>

type Feature struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name           string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        DefaultVariant string   `protobuf:"bytes,2,opt,name=default_variant,json=defaultVariant,proto3" json:"default_variant,omitempty"`
        Variants       []string `protobuf:"bytes,3,rep,name=variants,proto3" json:"variants,omitempty"`
}

func (x *Feature) Reset() <span class="cov8" title="1">{
        *x = Feature{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Feature) String() string <span class="cov8" title="1">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Feature) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Feature) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Feature.ProtoReflect.Descriptor instead.
func (*Feature) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{3}
}</span>

func (x *Feature) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Feature) GetDefaultVariant() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DefaultVariant
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Feature) GetVariants() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Variants
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FeatureVariant struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name         string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Variant      string         `protobuf:"bytes,2,opt,name=variant,proto3" json:"variant,omitempty"`
        Source       *NameVariant   `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
        Type         string         `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
        Entity       string         `protobuf:"bytes,5,opt,name=entity,proto3" json:"entity,omitempty"`
        Created      string         `protobuf:"bytes,6,opt,name=created,proto3" json:"created,omitempty"`
        Owner        string         `protobuf:"bytes,7,opt,name=owner,proto3" json:"owner,omitempty"`
        Description  string         `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
        Provider     string         `protobuf:"bytes,9,opt,name=provider,proto3" json:"provider,omitempty"`
        Trainingsets []*NameVariant `protobuf:"bytes,10,rep,name=trainingsets,proto3" json:"trainingsets,omitempty"`
}

func (x *FeatureVariant) Reset() <span class="cov8" title="1">{
        *x = FeatureVariant{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureVariant) String() string <span class="cov8" title="1">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureVariant) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureVariant) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureVariant.ProtoReflect.Descriptor instead.
func (*FeatureVariant) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{4}
}</span>

func (x *FeatureVariant) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureVariant) GetVariant() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Variant
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureVariant) GetSource() *NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Source
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureVariant) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureVariant) GetEntity() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entity
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureVariant) GetCreated() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Created
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureVariant) GetOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureVariant) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureVariant) GetProvider() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Provider
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureVariant) GetTrainingsets() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trainingsets
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Label struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name           string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        DefaultVariant string   `protobuf:"bytes,2,opt,name=default_variant,json=defaultVariant,proto3" json:"default_variant,omitempty"`
        Variants       []string `protobuf:"bytes,3,rep,name=variants,proto3" json:"variants,omitempty"`
}

func (x *Label) Reset() <span class="cov0" title="0">{
        *x = Label{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Label) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Label) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Label) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Label.ProtoReflect.Descriptor instead.
func (*Label) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{5}
}</span>

func (x *Label) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Label) GetDefaultVariant() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DefaultVariant
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Label) GetVariants() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Variants
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type LabelVariant struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name         string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Variant      string         `protobuf:"bytes,2,opt,name=variant,proto3" json:"variant,omitempty"`
        Description  string         `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        Type         string         `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
        Source       *NameVariant   `protobuf:"bytes,5,opt,name=source,proto3" json:"source,omitempty"`
        Entity       string         `protobuf:"bytes,6,opt,name=entity,proto3" json:"entity,omitempty"`
        Created      string         `protobuf:"bytes,7,opt,name=created,proto3" json:"created,omitempty"`
        Owner        string         `protobuf:"bytes,8,opt,name=owner,proto3" json:"owner,omitempty"`
        Provider     string         `protobuf:"bytes,9,opt,name=provider,proto3" json:"provider,omitempty"`
        Trainingsets []*NameVariant `protobuf:"bytes,10,rep,name=trainingsets,proto3" json:"trainingsets,omitempty"`
}

func (x *LabelVariant) Reset() <span class="cov0" title="0">{
        *x = LabelVariant{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LabelVariant) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LabelVariant) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LabelVariant) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LabelVariant.ProtoReflect.Descriptor instead.
func (*LabelVariant) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{6}
}</span>

func (x *LabelVariant) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LabelVariant) GetVariant() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Variant
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LabelVariant) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LabelVariant) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LabelVariant) GetSource() *NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Source
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *LabelVariant) GetEntity() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entity
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LabelVariant) GetCreated() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Created
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LabelVariant) GetOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LabelVariant) GetProvider() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Provider
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LabelVariant) GetTrainingsets() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trainingsets
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Provider struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name         string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Description  string         `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        Type         string         `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
        Software     string         `protobuf:"bytes,4,opt,name=software,proto3" json:"software,omitempty"`
        Team         string         `protobuf:"bytes,5,opt,name=team,proto3" json:"team,omitempty"`
        Sources      []*NameVariant `protobuf:"bytes,7,rep,name=sources,proto3" json:"sources,omitempty"`
        Features     []*NameVariant `protobuf:"bytes,8,rep,name=features,proto3" json:"features,omitempty"`
        Trainingsets []*NameVariant `protobuf:"bytes,9,rep,name=trainingsets,proto3" json:"trainingsets,omitempty"`
        Labels       []*NameVariant `protobuf:"bytes,10,rep,name=labels,proto3" json:"labels,omitempty"`
}

func (x *Provider) Reset() <span class="cov0" title="0">{
        *x = Provider{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Provider) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Provider) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Provider) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Provider.ProtoReflect.Descriptor instead.
func (*Provider) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{7}
}</span>

func (x *Provider) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Provider) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Provider) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Provider) GetSoftware() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Software
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Provider) GetTeam() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Team
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Provider) GetSources() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sources
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Provider) GetFeatures() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Provider) GetTrainingsets() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trainingsets
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Provider) GetLabels() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Labels
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type TrainingSet struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name           string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        DefaultVariant string   `protobuf:"bytes,2,opt,name=default_variant,json=defaultVariant,proto3" json:"default_variant,omitempty"`
        Variants       []string `protobuf:"bytes,3,rep,name=variants,proto3" json:"variants,omitempty"`
}

func (x *TrainingSet) Reset() <span class="cov0" title="0">{
        *x = TrainingSet{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TrainingSet) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TrainingSet) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TrainingSet) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TrainingSet.ProtoReflect.Descriptor instead.
func (*TrainingSet) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{8}
}</span>

func (x *TrainingSet) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TrainingSet) GetDefaultVariant() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DefaultVariant
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TrainingSet) GetVariants() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Variants
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type TrainingSetVariant struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name        string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Variant     string         `protobuf:"bytes,2,opt,name=variant,proto3" json:"variant,omitempty"`
        Description string         `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        Owner       string         `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
        Created     string         `protobuf:"bytes,5,opt,name=created,proto3" json:"created,omitempty"`
        Provider    string         `protobuf:"bytes,6,opt,name=provider,proto3" json:"provider,omitempty"`
        Features    []*NameVariant `protobuf:"bytes,7,rep,name=features,proto3" json:"features,omitempty"`
        Label       *NameVariant   `protobuf:"bytes,8,opt,name=label,proto3" json:"label,omitempty"`
}

func (x *TrainingSetVariant) Reset() <span class="cov0" title="0">{
        *x = TrainingSetVariant{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TrainingSetVariant) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TrainingSetVariant) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TrainingSetVariant) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TrainingSetVariant.ProtoReflect.Descriptor instead.
func (*TrainingSetVariant) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{9}
}</span>

func (x *TrainingSetVariant) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TrainingSetVariant) GetVariant() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Variant
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TrainingSetVariant) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TrainingSetVariant) GetOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TrainingSetVariant) GetCreated() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Created
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TrainingSetVariant) GetProvider() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Provider
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TrainingSetVariant) GetFeatures() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TrainingSetVariant) GetLabel() *NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Label
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Entity struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name         string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Description  string         `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        Features     []*NameVariant `protobuf:"bytes,3,rep,name=features,proto3" json:"features,omitempty"`
        Labels       []*NameVariant `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels,omitempty"`
        Trainingsets []*NameVariant `protobuf:"bytes,5,rep,name=trainingsets,proto3" json:"trainingsets,omitempty"`
}

func (x *Entity) Reset() <span class="cov0" title="0">{
        *x = Entity{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Entity) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Entity) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Entity) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Entity.ProtoReflect.Descriptor instead.
func (*Entity) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{10}
}</span>

func (x *Entity) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Entity) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Entity) GetFeatures() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Entity) GetLabels() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Labels
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Entity) GetTrainingsets() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trainingsets
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Model struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name         string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Description  string         `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        Features     []*NameVariant `protobuf:"bytes,4,rep,name=features,proto3" json:"features,omitempty"`
        Labels       []*NameVariant `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty"`
        Trainingsets []*NameVariant `protobuf:"bytes,6,rep,name=trainingsets,proto3" json:"trainingsets,omitempty"`
}

func (x *Model) Reset() <span class="cov0" title="0">{
        *x = Model{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Model) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Model) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Model) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Model.ProtoReflect.Descriptor instead.
func (*Model) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{11}
}</span>

func (x *Model) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Model) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Model) GetFeatures() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Model) GetLabels() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Labels
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Model) GetTrainingsets() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trainingsets
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type User struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name         string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Features     []*NameVariant `protobuf:"bytes,2,rep,name=features,proto3" json:"features,omitempty"`
        Labels       []*NameVariant `protobuf:"bytes,3,rep,name=labels,proto3" json:"labels,omitempty"`
        Trainingsets []*NameVariant `protobuf:"bytes,4,rep,name=trainingsets,proto3" json:"trainingsets,omitempty"`
        Sources      []*NameVariant `protobuf:"bytes,5,rep,name=sources,proto3" json:"sources,omitempty"`
}

func (x *User) Reset() <span class="cov0" title="0">{
        *x = User{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *User) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*User) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *User) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use User.ProtoReflect.Descriptor instead.
func (*User) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{12}
}</span>

func (x *User) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *User) GetFeatures() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetLabels() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Labels
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetTrainingsets() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trainingsets
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *User) GetSources() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sources
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Source struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name           string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        DefaultVariant string   `protobuf:"bytes,2,opt,name=default_variant,json=defaultVariant,proto3" json:"default_variant,omitempty"`
        Variants       []string `protobuf:"bytes,3,rep,name=variants,proto3" json:"variants,omitempty"`
}

func (x *Source) Reset() <span class="cov0" title="0">{
        *x = Source{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[13]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Source) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Source) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Source) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[13]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Source.ProtoReflect.Descriptor instead.
func (*Source) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{13}
}</span>

func (x *Source) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Source) GetDefaultVariant() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DefaultVariant
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Source) GetVariants() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Variants
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SourceVariant struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name         string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Variant      string         `protobuf:"bytes,2,opt,name=variant,proto3" json:"variant,omitempty"`
        Type         string         `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
        Owner        string         `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
        Description  string         `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
        Provider     string         `protobuf:"bytes,6,opt,name=provider,proto3" json:"provider,omitempty"`
        Created      string         `protobuf:"bytes,7,opt,name=created,proto3" json:"created,omitempty"`
        Trainingsets []*NameVariant `protobuf:"bytes,8,rep,name=trainingsets,proto3" json:"trainingsets,omitempty"`
        Features     []*NameVariant `protobuf:"bytes,9,rep,name=features,proto3" json:"features,omitempty"`
        Labels       []*NameVariant `protobuf:"bytes,10,rep,name=labels,proto3" json:"labels,omitempty"`
}

func (x *SourceVariant) Reset() <span class="cov0" title="0">{
        *x = SourceVariant{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_metadata_proto_metadata_proto_msgTypes[14]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SourceVariant) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SourceVariant) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SourceVariant) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_metadata_proto_metadata_proto_msgTypes[14]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SourceVariant.ProtoReflect.Descriptor instead.
func (*SourceVariant) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_metadata_proto_metadata_proto_rawDescGZIP(), []int{14}
}</span>

func (x *SourceVariant) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SourceVariant) GetVariant() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Variant
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SourceVariant) GetType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SourceVariant) GetOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SourceVariant) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SourceVariant) GetProvider() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Provider
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SourceVariant) GetCreated() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Created
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SourceVariant) GetTrainingsets() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Trainingsets
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SourceVariant) GetFeatures() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SourceVariant) GetLabels() []*NameVariant <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Labels
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_metadata_proto_metadata_proto protoreflect.FileDescriptor

var file_metadata_proto_metadata_proto_rawDesc = []byte{
        0x0a, 0x1d, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
        0x22, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72,
        0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x22, 0x1a, 0x0a, 0x04, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e,
        0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22,
        0x3b, 0x0a, 0x0b, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x12, 0x12,
        0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61,
        0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x22, 0x07, 0x0a, 0x05,
        0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x62, 0x0a, 0x07, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x12, 0x27, 0x0a, 0x0f, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f,
        0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x64,
        0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x12, 0x1a, 0x0a,
        0x08, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52,
        0x08, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x73, 0x22, 0xf6, 0x02, 0x0a, 0x0e, 0x46, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x12, 0x12, 0x0a, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65,
        0x12, 0x18, 0x0a, 0x07, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x07, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x12, 0x47, 0x0a, 0x06, 0x73, 0x6f,
        0x75, 0x72, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67,
        0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
        0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x06, 0x73, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x6e, 0x74, 0x69, 0x74,
        0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12,
        0x18, 0x0a, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e,
        0x65, 0x72, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12,
        0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x08,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x18, 0x09, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x53, 0x0a,
        0x0c, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x73, 0x65, 0x74, 0x73, 0x18, 0x0a, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72,
        0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61,
        0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72,
        0x69, 0x61, 0x6e, 0x74, 0x52, 0x0c, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x73, 0x65,
        0x74, 0x73, 0x22, 0x60, 0x0a, 0x05, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x6e,
        0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12,
        0x27, 0x0a, 0x0f, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x76, 0x61, 0x72, 0x69, 0x61,
        0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
        0x74, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x76, 0x61, 0x72, 0x69,
        0x61, 0x6e, 0x74, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x76, 0x61, 0x72, 0x69,
        0x61, 0x6e, 0x74, 0x73, 0x22, 0xf4, 0x02, 0x0a, 0x0c, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x56, 0x61,
        0x72, 0x69, 0x61, 0x6e, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x61, 0x72,
        0x69, 0x61, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x61, 0x72, 0x69,
        0x61, 0x6e, 0x74, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x04, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x47, 0x0a, 0x06, 0x73, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74,
        0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e,
        0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e,
        0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x06, 0x73, 0x6f, 0x75, 0x72,
        0x63, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x18, 0x06, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x06, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x72,
        0x65, 0x61, 0x74, 0x65, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x72, 0x65,
        0x61, 0x74, 0x65, 0x64, 0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x08, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72,
        0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x72,
        0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x53, 0x0a, 0x0c, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x69,
        0x6e, 0x67, 0x73, 0x65, 0x74, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x0c, 0x74,
        0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x73, 0x65, 0x74, 0x73, 0x22, 0xba, 0x03, 0x0a, 0x08,
        0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b,
        0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12,
        0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x79,
        0x70, 0x65, 0x12, 0x1a, 0x0a, 0x08, 0x73, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x73, 0x6f, 0x66, 0x74, 0x77, 0x61, 0x72, 0x65, 0x12, 0x12,
        0x0a, 0x04, 0x74, 0x65, 0x61, 0x6d, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x74, 0x65,
        0x61, 0x6d, 0x12, 0x49, 0x0a, 0x07, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x07, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72,
        0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61,
        0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72,
        0x69, 0x61, 0x6e, 0x74, 0x52, 0x07, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x12, 0x4b, 0x0a,
        0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74,
        0x52, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x53, 0x0a, 0x0c, 0x74, 0x72,
        0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x73, 0x65, 0x74, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b,
        0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73,
        0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e,
        0x74, 0x52, 0x0c, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x73, 0x65, 0x74, 0x73, 0x12,
        0x47, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74,
        0x52, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x22, 0x66, 0x0a, 0x0b, 0x54, 0x72, 0x61, 0x69,
        0x6e, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x27, 0x0a, 0x0f, 0x64,
        0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x56, 0x61, 0x72,
        0x69, 0x61, 0x6e, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x73,
        0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x73,
        0x22, 0xc4, 0x02, 0x0a, 0x12, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x74,
        0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x76,
        0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x61,
        0x72, 0x69, 0x61, 0x6e, 0x74, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63,
        0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72,
        0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x18, 0x0a,
        0x07, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
        0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69,
        0x64, 0x65, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69,
        0x64, 0x65, 0x72, 0x12, 0x4b, 0x0a, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18,
        0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66,
        0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61,
        0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56,
        0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73,
        0x12, 0x45, 0x0a, 0x05, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74,
        0x52, 0x05, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x22, 0xa9, 0x02, 0x0a, 0x06, 0x45, 0x6e, 0x74, 0x69,
        0x74, 0x79, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73,
        0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x4b, 0x0a, 0x08, 0x66, 0x65, 0x61, 0x74,
        0x75, 0x72, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67,
        0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
        0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x08, 0x66, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x47, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18,
        0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66,
        0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61,
        0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56,
        0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x12, 0x53,
        0x0a, 0x0c, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x73, 0x65, 0x74, 0x73, 0x18, 0x05,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f,
        0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64,
        0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61,
        0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x0c, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x73,
        0x65, 0x74, 0x73, 0x22, 0xa8, 0x02, 0x0a, 0x05, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x12, 0x12, 0x0a,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x12, 0x4b, 0x0a, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18,
        0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66,
        0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61,
        0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56,
        0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73,
        0x12, 0x47, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b,
        0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73,
        0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e,
        0x74, 0x52, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x12, 0x53, 0x0a, 0x0c, 0x74, 0x72, 0x61,
        0x69, 0x6e, 0x69, 0x6e, 0x67, 0x73, 0x65, 0x74, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74,
        0x52, 0x0c, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x73, 0x65, 0x74, 0x73, 0x22, 0xd0,
        0x02, 0x0a, 0x04, 0x55, 0x73, 0x65, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x4b, 0x0a, 0x08, 0x66,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e,
        0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76,
        0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x08,
        0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x47, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65,
        0x6c, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d,
        0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61,
        0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c,
        0x73, 0x12, 0x53, 0x0a, 0x0c, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x73, 0x65, 0x74,
        0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65,
        0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d,
        0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x0c, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x69,
        0x6e, 0x67, 0x73, 0x65, 0x74, 0x73, 0x12, 0x49, 0x0a, 0x07, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
        0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65,
        0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d,
        0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x07, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65,
        0x73, 0x22, 0x61, 0x0a, 0x06, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e,
        0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12,
        0x27, 0x0a, 0x0f, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x76, 0x61, 0x72, 0x69, 0x61,
        0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
        0x74, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x76, 0x61, 0x72, 0x69,
        0x61, 0x6e, 0x74, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x76, 0x61, 0x72, 0x69,
        0x61, 0x6e, 0x74, 0x73, 0x22, 0xaa, 0x03, 0x0a, 0x0d, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x56,
        0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x61,
        0x72, 0x69, 0x61, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x61, 0x72,
        0x69, 0x61, 0x6e, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65,
        0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x20,
        0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x12, 0x1a, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x18, 0x06, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x18, 0x0a, 0x07,
        0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63,
        0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x12, 0x53, 0x0a, 0x0c, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x69,
        0x6e, 0x67, 0x73, 0x65, 0x74, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x0c, 0x74,
        0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x73, 0x65, 0x74, 0x73, 0x12, 0x4b, 0x0a, 0x08, 0x66,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e,
        0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76,
        0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x08,
        0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x47, 0x0a, 0x06, 0x6c, 0x61, 0x62, 0x65,
        0x6c, 0x73, 0x18, 0x0a, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d,
        0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61,
        0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x52, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c,
        0x73, 0x32, 0x93, 0x18, 0x0a, 0x08, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x68,
        0x0a, 0x0c, 0x4c, 0x69, 0x73, 0x74, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x29,
        0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72,
        0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x2b, 0x2e, 0x66, 0x65, 0x61, 0x74,
        0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e,
        0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x46,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x30, 0x01, 0x12, 0x75, 0x0a, 0x14, 0x43, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74,
        0x12, 0x32, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73,
        0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x61, 0x72,
        0x69, 0x61, 0x6e, 0x74, 0x1a, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f,
        0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64,
        0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12,
        0x68, 0x0a, 0x0b, 0x47, 0x65, 0x74, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x28,
        0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72,
        0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x1a, 0x2b, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d,
        0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x46, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x28, 0x01, 0x30, 0x01, 0x12, 0x7d, 0x0a, 0x12, 0x47, 0x65, 0x74,
        0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x73, 0x12,
        0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74,
        0x1a, 0x32, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73,
        0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x61, 0x72,
        0x69, 0x61, 0x6e, 0x74, 0x28, 0x01, 0x30, 0x01, 0x12, 0x64, 0x0a, 0x0a, 0x4c, 0x69, 0x73, 0x74,
        0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x12, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74,
        0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74,
        0x79, 0x1a, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e,
        0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x30, 0x01, 0x12, 0x71,
        0x0a, 0x12, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x56, 0x61, 0x72,
        0x69, 0x61, 0x6e, 0x74, 0x12, 0x30, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f,
        0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64,
        0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x56,
        0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x1a, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74,
        0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74,
        0x79, 0x12, 0x64, 0x0a, 0x09, 0x47, 0x65, 0x74, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x12, 0x28,
        0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72,
        0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x1a, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d,
        0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4c, 0x61,
        0x62, 0x65, 0x6c, 0x28, 0x01, 0x30, 0x01, 0x12, 0x79, 0x0a, 0x10, 0x47, 0x65, 0x74, 0x4c, 0x61,
        0x62, 0x65, 0x6c, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x73, 0x12, 0x2f, 0x2e, 0x66, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e,
        0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x1a, 0x30, 0x2e, 0x66,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x2e, 0x4c, 0x61, 0x62, 0x65, 0x6c, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x28, 0x01,
        0x30, 0x01, 0x12, 0x70, 0x0a, 0x10, 0x4c, 0x69, 0x73, 0x74, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69,
        0x6e, 0x67, 0x53, 0x65, 0x74, 0x73, 0x12, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74,
        0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74,
        0x79, 0x1a, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e,
        0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x53,
        0x65, 0x74, 0x30, 0x01, 0x12, 0x7d, 0x0a, 0x18, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x54, 0x72,
        0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x74, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74,
        0x12, 0x36, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73,
        0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x53, 0x65,
        0x74, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x1a, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d,
        0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6d,
        0x70, 0x74, 0x79, 0x12, 0x70, 0x0a, 0x0f, 0x47, 0x65, 0x74, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69,
        0x6e, 0x67, 0x53, 0x65, 0x74, 0x73, 0x12, 0x28, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74,
        0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65,
        0x1a, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73,
        0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x53, 0x65,
        0x74, 0x28, 0x01, 0x30, 0x01, 0x12, 0x85, 0x01, 0x0a, 0x16, 0x47, 0x65, 0x74, 0x54, 0x72, 0x61,
        0x69, 0x6e, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x74, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x73,
        0x12, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73,
        0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e,
        0x74, 0x1a, 0x36, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e,
        0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x53,
        0x65, 0x74, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x28, 0x01, 0x30, 0x01, 0x12, 0x66, 0x0a,
        0x0b, 0x4c, 0x69, 0x73, 0x74, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x12, 0x29, 0x2e, 0x66,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x2a, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65,
        0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x53, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x30, 0x01, 0x12, 0x73, 0x0a, 0x13, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x53,
        0x6f, 0x75, 0x72, 0x63, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x12, 0x31, 0x2e, 0x66,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x2e, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x1a,
        0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x66, 0x0a, 0x0a, 0x47, 0x65,
        0x74, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x12, 0x28, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d,
        0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61,
        0x6d, 0x65, 0x1a, 0x2a, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d,
        0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74,
        0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x28, 0x01,
        0x30, 0x01, 0x12, 0x7b, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x56,
        0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x73, 0x12, 0x2f, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65,
        0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d,
        0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x1a, 0x31, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d,
        0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x53, 0x6f,
        0x75, 0x72, 0x63, 0x65, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x28, 0x01, 0x30, 0x01, 0x12,
        0x62, 0x0a, 0x09, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x73, 0x65, 0x72, 0x73, 0x12, 0x29, 0x2e, 0x66,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x28, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65,
        0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x55, 0x73, 0x65,
        0x72, 0x30, 0x01, 0x12, 0x61, 0x0a, 0x0a, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65,
        0x72, 0x12, 0x28, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e,
        0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x1a, 0x29, 0x2e, 0x66, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e,
        0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x62, 0x0a, 0x08, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65,
        0x72, 0x73, 0x12, 0x28, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d,
        0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74,
        0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x1a, 0x28, 0x2e, 0x66,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x28, 0x01, 0x30, 0x01, 0x12, 0x6a, 0x0a, 0x0d, 0x4c, 0x69,
        0x73, 0x74, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x73, 0x12, 0x29, 0x2e, 0x66, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e,
        0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x2c, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74,
        0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x50, 0x72, 0x6f, 0x76,
        0x69, 0x64, 0x65, 0x72, 0x30, 0x01, 0x12, 0x69, 0x0a, 0x0e, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x12, 0x2c, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d,
        0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x50, 0x72,
        0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x1a, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74,
        0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74,
        0x79, 0x12, 0x6a, 0x0a, 0x0c, 0x47, 0x65, 0x74, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72,
        0x73, 0x12, 0x28, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e,
        0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x1a, 0x2c, 0x2e, 0x66, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e,
        0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x50, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x28, 0x01, 0x30, 0x01, 0x12, 0x67, 0x0a,
        0x0c, 0x4c, 0x69, 0x73, 0x74, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12, 0x29, 0x2e,
        0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76,
        0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a, 0x2a, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d,
        0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6e,
        0x74, 0x69, 0x74, 0x79, 0x30, 0x01, 0x12, 0x65, 0x0a, 0x0c, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x2a, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74,
        0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6e, 0x74, 0x69,
        0x74, 0x79, 0x1a, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d,
        0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74,
        0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x12, 0x67, 0x0a,
        0x0b, 0x47, 0x65, 0x74, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12, 0x28, 0x2e, 0x66,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x1a, 0x2a, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74,
        0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6e, 0x74, 0x69,
        0x74, 0x79, 0x28, 0x01, 0x30, 0x01, 0x12, 0x64, 0x0a, 0x0a, 0x4c, 0x69, 0x73, 0x74, 0x4d, 0x6f,
        0x64, 0x65, 0x6c, 0x73, 0x12, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f,
        0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64,
        0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x1a,
        0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x30, 0x01, 0x12, 0x63, 0x0a, 0x0b,
        0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x12, 0x29, 0x2e, 0x66, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e,
        0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x1a, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74,
        0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6d, 0x70, 0x74,
        0x79, 0x12, 0x64, 0x0a, 0x09, 0x47, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x73, 0x12, 0x28,
        0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72,
        0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x1a, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x6d,
        0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x4d, 0x6f,
        0x64, 0x65, 0x6c, 0x28, 0x01, 0x30, 0x01, 0x42, 0x2f, 0x5a, 0x2d, 0x67, 0x69, 0x74, 0x68, 0x75,
        0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72,
        0x6d, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61,
        0x74, 0x61, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_metadata_proto_metadata_proto_rawDescOnce sync.Once
        file_metadata_proto_metadata_proto_rawDescData = file_metadata_proto_metadata_proto_rawDesc
)

func file_metadata_proto_metadata_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_metadata_proto_metadata_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_metadata_proto_metadata_proto_rawDescData = protoimpl.X.CompressGZIP(file_metadata_proto_metadata_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_metadata_proto_metadata_proto_rawDescData</span>
}

var file_metadata_proto_metadata_proto_msgTypes = make([]protoimpl.MessageInfo, 15)
var file_metadata_proto_metadata_proto_goTypes = []interface{}{
        (*Name)(nil),               // 0: featureform.serving.metadata.proto.Name
        (*NameVariant)(nil),        // 1: featureform.serving.metadata.proto.NameVariant
        (*Empty)(nil),              // 2: featureform.serving.metadata.proto.Empty
        (*Feature)(nil),            // 3: featureform.serving.metadata.proto.Feature
        (*FeatureVariant)(nil),     // 4: featureform.serving.metadata.proto.FeatureVariant
        (*Label)(nil),              // 5: featureform.serving.metadata.proto.Label
        (*LabelVariant)(nil),       // 6: featureform.serving.metadata.proto.LabelVariant
        (*Provider)(nil),           // 7: featureform.serving.metadata.proto.Provider
        (*TrainingSet)(nil),        // 8: featureform.serving.metadata.proto.TrainingSet
        (*TrainingSetVariant)(nil), // 9: featureform.serving.metadata.proto.TrainingSetVariant
        (*Entity)(nil),             // 10: featureform.serving.metadata.proto.Entity
        (*Model)(nil),              // 11: featureform.serving.metadata.proto.Model
        (*User)(nil),               // 12: featureform.serving.metadata.proto.User
        (*Source)(nil),             // 13: featureform.serving.metadata.proto.Source
        (*SourceVariant)(nil),      // 14: featureform.serving.metadata.proto.SourceVariant
}
var file_metadata_proto_metadata_proto_depIdxs = []int32{
        1,  // 0: featureform.serving.metadata.proto.FeatureVariant.source:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 1: featureform.serving.metadata.proto.FeatureVariant.trainingsets:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 2: featureform.serving.metadata.proto.LabelVariant.source:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 3: featureform.serving.metadata.proto.LabelVariant.trainingsets:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 4: featureform.serving.metadata.proto.Provider.sources:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 5: featureform.serving.metadata.proto.Provider.features:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 6: featureform.serving.metadata.proto.Provider.trainingsets:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 7: featureform.serving.metadata.proto.Provider.labels:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 8: featureform.serving.metadata.proto.TrainingSetVariant.features:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 9: featureform.serving.metadata.proto.TrainingSetVariant.label:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 10: featureform.serving.metadata.proto.Entity.features:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 11: featureform.serving.metadata.proto.Entity.labels:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 12: featureform.serving.metadata.proto.Entity.trainingsets:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 13: featureform.serving.metadata.proto.Model.features:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 14: featureform.serving.metadata.proto.Model.labels:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 15: featureform.serving.metadata.proto.Model.trainingsets:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 16: featureform.serving.metadata.proto.User.features:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 17: featureform.serving.metadata.proto.User.labels:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 18: featureform.serving.metadata.proto.User.trainingsets:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 19: featureform.serving.metadata.proto.User.sources:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 20: featureform.serving.metadata.proto.SourceVariant.trainingsets:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 21: featureform.serving.metadata.proto.SourceVariant.features:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        1,  // 22: featureform.serving.metadata.proto.SourceVariant.labels:type_name -&gt; featureform.serving.metadata.proto.NameVariant
        2,  // 23: featureform.serving.metadata.proto.Metadata.ListFeatures:input_type -&gt; featureform.serving.metadata.proto.Empty
        4,  // 24: featureform.serving.metadata.proto.Metadata.CreateFeatureVariant:input_type -&gt; featureform.serving.metadata.proto.FeatureVariant
        0,  // 25: featureform.serving.metadata.proto.Metadata.GetFeatures:input_type -&gt; featureform.serving.metadata.proto.Name
        1,  // 26: featureform.serving.metadata.proto.Metadata.GetFeatureVariants:input_type -&gt; featureform.serving.metadata.proto.NameVariant
        2,  // 27: featureform.serving.metadata.proto.Metadata.ListLabels:input_type -&gt; featureform.serving.metadata.proto.Empty
        6,  // 28: featureform.serving.metadata.proto.Metadata.CreateLabelVariant:input_type -&gt; featureform.serving.metadata.proto.LabelVariant
        0,  // 29: featureform.serving.metadata.proto.Metadata.GetLabels:input_type -&gt; featureform.serving.metadata.proto.Name
        1,  // 30: featureform.serving.metadata.proto.Metadata.GetLabelVariants:input_type -&gt; featureform.serving.metadata.proto.NameVariant
        2,  // 31: featureform.serving.metadata.proto.Metadata.ListTrainingSets:input_type -&gt; featureform.serving.metadata.proto.Empty
        9,  // 32: featureform.serving.metadata.proto.Metadata.CreateTrainingSetVariant:input_type -&gt; featureform.serving.metadata.proto.TrainingSetVariant
        0,  // 33: featureform.serving.metadata.proto.Metadata.GetTrainingSets:input_type -&gt; featureform.serving.metadata.proto.Name
        1,  // 34: featureform.serving.metadata.proto.Metadata.GetTrainingSetVariants:input_type -&gt; featureform.serving.metadata.proto.NameVariant
        2,  // 35: featureform.serving.metadata.proto.Metadata.ListSources:input_type -&gt; featureform.serving.metadata.proto.Empty
        14, // 36: featureform.serving.metadata.proto.Metadata.CreateSourceVariant:input_type -&gt; featureform.serving.metadata.proto.SourceVariant
        0,  // 37: featureform.serving.metadata.proto.Metadata.GetSources:input_type -&gt; featureform.serving.metadata.proto.Name
        1,  // 38: featureform.serving.metadata.proto.Metadata.GetSourceVariants:input_type -&gt; featureform.serving.metadata.proto.NameVariant
        2,  // 39: featureform.serving.metadata.proto.Metadata.ListUsers:input_type -&gt; featureform.serving.metadata.proto.Empty
        12, // 40: featureform.serving.metadata.proto.Metadata.CreateUser:input_type -&gt; featureform.serving.metadata.proto.User
        0,  // 41: featureform.serving.metadata.proto.Metadata.GetUsers:input_type -&gt; featureform.serving.metadata.proto.Name
        2,  // 42: featureform.serving.metadata.proto.Metadata.ListProviders:input_type -&gt; featureform.serving.metadata.proto.Empty
        7,  // 43: featureform.serving.metadata.proto.Metadata.CreateProvider:input_type -&gt; featureform.serving.metadata.proto.Provider
        0,  // 44: featureform.serving.metadata.proto.Metadata.GetProviders:input_type -&gt; featureform.serving.metadata.proto.Name
        2,  // 45: featureform.serving.metadata.proto.Metadata.ListEntities:input_type -&gt; featureform.serving.metadata.proto.Empty
        10, // 46: featureform.serving.metadata.proto.Metadata.CreateEntity:input_type -&gt; featureform.serving.metadata.proto.Entity
        0,  // 47: featureform.serving.metadata.proto.Metadata.GetEntities:input_type -&gt; featureform.serving.metadata.proto.Name
        2,  // 48: featureform.serving.metadata.proto.Metadata.ListModels:input_type -&gt; featureform.serving.metadata.proto.Empty
        11, // 49: featureform.serving.metadata.proto.Metadata.CreateModel:input_type -&gt; featureform.serving.metadata.proto.Model
        0,  // 50: featureform.serving.metadata.proto.Metadata.GetModels:input_type -&gt; featureform.serving.metadata.proto.Name
        3,  // 51: featureform.serving.metadata.proto.Metadata.ListFeatures:output_type -&gt; featureform.serving.metadata.proto.Feature
        2,  // 52: featureform.serving.metadata.proto.Metadata.CreateFeatureVariant:output_type -&gt; featureform.serving.metadata.proto.Empty
        3,  // 53: featureform.serving.metadata.proto.Metadata.GetFeatures:output_type -&gt; featureform.serving.metadata.proto.Feature
        4,  // 54: featureform.serving.metadata.proto.Metadata.GetFeatureVariants:output_type -&gt; featureform.serving.metadata.proto.FeatureVariant
        5,  // 55: featureform.serving.metadata.proto.Metadata.ListLabels:output_type -&gt; featureform.serving.metadata.proto.Label
        2,  // 56: featureform.serving.metadata.proto.Metadata.CreateLabelVariant:output_type -&gt; featureform.serving.metadata.proto.Empty
        5,  // 57: featureform.serving.metadata.proto.Metadata.GetLabels:output_type -&gt; featureform.serving.metadata.proto.Label
        6,  // 58: featureform.serving.metadata.proto.Metadata.GetLabelVariants:output_type -&gt; featureform.serving.metadata.proto.LabelVariant
        8,  // 59: featureform.serving.metadata.proto.Metadata.ListTrainingSets:output_type -&gt; featureform.serving.metadata.proto.TrainingSet
        2,  // 60: featureform.serving.metadata.proto.Metadata.CreateTrainingSetVariant:output_type -&gt; featureform.serving.metadata.proto.Empty
        8,  // 61: featureform.serving.metadata.proto.Metadata.GetTrainingSets:output_type -&gt; featureform.serving.metadata.proto.TrainingSet
        9,  // 62: featureform.serving.metadata.proto.Metadata.GetTrainingSetVariants:output_type -&gt; featureform.serving.metadata.proto.TrainingSetVariant
        13, // 63: featureform.serving.metadata.proto.Metadata.ListSources:output_type -&gt; featureform.serving.metadata.proto.Source
        2,  // 64: featureform.serving.metadata.proto.Metadata.CreateSourceVariant:output_type -&gt; featureform.serving.metadata.proto.Empty
        13, // 65: featureform.serving.metadata.proto.Metadata.GetSources:output_type -&gt; featureform.serving.metadata.proto.Source
        14, // 66: featureform.serving.metadata.proto.Metadata.GetSourceVariants:output_type -&gt; featureform.serving.metadata.proto.SourceVariant
        12, // 67: featureform.serving.metadata.proto.Metadata.ListUsers:output_type -&gt; featureform.serving.metadata.proto.User
        2,  // 68: featureform.serving.metadata.proto.Metadata.CreateUser:output_type -&gt; featureform.serving.metadata.proto.Empty
        12, // 69: featureform.serving.metadata.proto.Metadata.GetUsers:output_type -&gt; featureform.serving.metadata.proto.User
        7,  // 70: featureform.serving.metadata.proto.Metadata.ListProviders:output_type -&gt; featureform.serving.metadata.proto.Provider
        2,  // 71: featureform.serving.metadata.proto.Metadata.CreateProvider:output_type -&gt; featureform.serving.metadata.proto.Empty
        7,  // 72: featureform.serving.metadata.proto.Metadata.GetProviders:output_type -&gt; featureform.serving.metadata.proto.Provider
        10, // 73: featureform.serving.metadata.proto.Metadata.ListEntities:output_type -&gt; featureform.serving.metadata.proto.Entity
        2,  // 74: featureform.serving.metadata.proto.Metadata.CreateEntity:output_type -&gt; featureform.serving.metadata.proto.Empty
        10, // 75: featureform.serving.metadata.proto.Metadata.GetEntities:output_type -&gt; featureform.serving.metadata.proto.Entity
        11, // 76: featureform.serving.metadata.proto.Metadata.ListModels:output_type -&gt; featureform.serving.metadata.proto.Model
        2,  // 77: featureform.serving.metadata.proto.Metadata.CreateModel:output_type -&gt; featureform.serving.metadata.proto.Empty
        11, // 78: featureform.serving.metadata.proto.Metadata.GetModels:output_type -&gt; featureform.serving.metadata.proto.Model
        51, // [51:79] is the sub-list for method output_type
        23, // [23:51] is the sub-list for method input_type
        23, // [23:23] is the sub-list for extension type_name
        23, // [23:23] is the sub-list for extension extendee
        0,  // [0:23] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_metadata_proto_metadata_proto_init() }</span>
func file_metadata_proto_metadata_proto_init() <span class="cov8" title="1">{
        if File_metadata_proto_metadata_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_metadata_proto_metadata_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Name); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_metadata_proto_metadata_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*NameVariant); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_metadata_proto_metadata_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Empty); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_metadata_proto_metadata_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Feature); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_metadata_proto_metadata_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureVariant); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_metadata_proto_metadata_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Label); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_metadata_proto_metadata_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LabelVariant); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_metadata_proto_metadata_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Provider); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_metadata_proto_metadata_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TrainingSet); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_metadata_proto_metadata_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TrainingSetVariant); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_metadata_proto_metadata_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Entity); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_metadata_proto_metadata_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Model); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_metadata_proto_metadata_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*User); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_metadata_proto_metadata_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Source); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_metadata_proto_metadata_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SourceVariant); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_metadata_proto_metadata_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   15,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_metadata_proto_metadata_proto_goTypes,
                DependencyIndexes: file_metadata_proto_metadata_proto_depIdxs,
                MessageInfos:      file_metadata_proto_metadata_proto_msgTypes,
        }.Build()
        File_metadata_proto_metadata_proto = out.File
        file_metadata_proto_metadata_proto_rawDesc = nil
        file_metadata_proto_metadata_proto_goTypes = nil
        file_metadata_proto_metadata_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: metadata/proto/metadata.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MetadataClient is the client API for Metadata service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MetadataClient interface {
        ListFeatures(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListFeaturesClient, error)
        CreateFeatureVariant(ctx context.Context, in *FeatureVariant, opts ...grpc.CallOption) (*Empty, error)
        GetFeatures(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetFeaturesClient, error)
        GetFeatureVariants(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetFeatureVariantsClient, error)
        ListLabels(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListLabelsClient, error)
        CreateLabelVariant(ctx context.Context, in *LabelVariant, opts ...grpc.CallOption) (*Empty, error)
        GetLabels(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetLabelsClient, error)
        GetLabelVariants(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetLabelVariantsClient, error)
        ListTrainingSets(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListTrainingSetsClient, error)
        CreateTrainingSetVariant(ctx context.Context, in *TrainingSetVariant, opts ...grpc.CallOption) (*Empty, error)
        GetTrainingSets(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetTrainingSetsClient, error)
        GetTrainingSetVariants(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetTrainingSetVariantsClient, error)
        ListSources(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListSourcesClient, error)
        CreateSourceVariant(ctx context.Context, in *SourceVariant, opts ...grpc.CallOption) (*Empty, error)
        GetSources(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetSourcesClient, error)
        GetSourceVariants(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetSourceVariantsClient, error)
        ListUsers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListUsersClient, error)
        CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Empty, error)
        GetUsers(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetUsersClient, error)
        ListProviders(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListProvidersClient, error)
        CreateProvider(ctx context.Context, in *Provider, opts ...grpc.CallOption) (*Empty, error)
        GetProviders(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetProvidersClient, error)
        ListEntities(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListEntitiesClient, error)
        CreateEntity(ctx context.Context, in *Entity, opts ...grpc.CallOption) (*Empty, error)
        GetEntities(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetEntitiesClient, error)
        ListModels(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListModelsClient, error)
        CreateModel(ctx context.Context, in *Model, opts ...grpc.CallOption) (*Empty, error)
        GetModels(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetModelsClient, error)
}

type metadataClient struct {
        cc grpc.ClientConnInterface
}

func NewMetadataClient(cc grpc.ClientConnInterface) MetadataClient <span class="cov0" title="0">{
        return &amp;metadataClient{cc}
}</span>

func (c *metadataClient) ListFeatures(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListFeaturesClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[0], "/featureform.serving.metadata.proto.Metadata/ListFeatures", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataListFeaturesClient{stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

type Metadata_ListFeaturesClient interface {
        Recv() (*Feature, error)
        grpc.ClientStream
}

type metadataListFeaturesClient struct {
        grpc.ClientStream
}

func (x *metadataListFeaturesClient) Recv() (*Feature, error) <span class="cov0" title="0">{
        m := new(Feature)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) CreateFeatureVariant(ctx context.Context, in *FeatureVariant, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        out := new(Empty)
        err := c.cc.Invoke(ctx, "/featureform.serving.metadata.proto.Metadata/CreateFeatureVariant", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *metadataClient) GetFeatures(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetFeaturesClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[1], "/featureform.serving.metadata.proto.Metadata/GetFeatures", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataGetFeaturesClient{stream}
        return x, nil</span>
}

type Metadata_GetFeaturesClient interface {
        Send(*Name) error
        Recv() (*Feature, error)
        grpc.ClientStream
}

type metadataGetFeaturesClient struct {
        grpc.ClientStream
}

func (x *metadataGetFeaturesClient) Send(m *Name) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *metadataGetFeaturesClient) Recv() (*Feature, error) <span class="cov0" title="0">{
        m := new(Feature)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) GetFeatureVariants(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetFeatureVariantsClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[2], "/featureform.serving.metadata.proto.Metadata/GetFeatureVariants", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataGetFeatureVariantsClient{stream}
        return x, nil</span>
}

type Metadata_GetFeatureVariantsClient interface {
        Send(*NameVariant) error
        Recv() (*FeatureVariant, error)
        grpc.ClientStream
}

type metadataGetFeatureVariantsClient struct {
        grpc.ClientStream
}

func (x *metadataGetFeatureVariantsClient) Send(m *NameVariant) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *metadataGetFeatureVariantsClient) Recv() (*FeatureVariant, error) <span class="cov0" title="0">{
        m := new(FeatureVariant)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) ListLabels(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListLabelsClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[3], "/featureform.serving.metadata.proto.Metadata/ListLabels", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataListLabelsClient{stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

type Metadata_ListLabelsClient interface {
        Recv() (*Label, error)
        grpc.ClientStream
}

type metadataListLabelsClient struct {
        grpc.ClientStream
}

func (x *metadataListLabelsClient) Recv() (*Label, error) <span class="cov0" title="0">{
        m := new(Label)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) CreateLabelVariant(ctx context.Context, in *LabelVariant, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        out := new(Empty)
        err := c.cc.Invoke(ctx, "/featureform.serving.metadata.proto.Metadata/CreateLabelVariant", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *metadataClient) GetLabels(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetLabelsClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[4], "/featureform.serving.metadata.proto.Metadata/GetLabels", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataGetLabelsClient{stream}
        return x, nil</span>
}

type Metadata_GetLabelsClient interface {
        Send(*Name) error
        Recv() (*Label, error)
        grpc.ClientStream
}

type metadataGetLabelsClient struct {
        grpc.ClientStream
}

func (x *metadataGetLabelsClient) Send(m *Name) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *metadataGetLabelsClient) Recv() (*Label, error) <span class="cov0" title="0">{
        m := new(Label)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) GetLabelVariants(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetLabelVariantsClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[5], "/featureform.serving.metadata.proto.Metadata/GetLabelVariants", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataGetLabelVariantsClient{stream}
        return x, nil</span>
}

type Metadata_GetLabelVariantsClient interface {
        Send(*NameVariant) error
        Recv() (*LabelVariant, error)
        grpc.ClientStream
}

type metadataGetLabelVariantsClient struct {
        grpc.ClientStream
}

func (x *metadataGetLabelVariantsClient) Send(m *NameVariant) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *metadataGetLabelVariantsClient) Recv() (*LabelVariant, error) <span class="cov0" title="0">{
        m := new(LabelVariant)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) ListTrainingSets(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListTrainingSetsClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[6], "/featureform.serving.metadata.proto.Metadata/ListTrainingSets", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataListTrainingSetsClient{stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

type Metadata_ListTrainingSetsClient interface {
        Recv() (*TrainingSet, error)
        grpc.ClientStream
}

type metadataListTrainingSetsClient struct {
        grpc.ClientStream
}

func (x *metadataListTrainingSetsClient) Recv() (*TrainingSet, error) <span class="cov0" title="0">{
        m := new(TrainingSet)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) CreateTrainingSetVariant(ctx context.Context, in *TrainingSetVariant, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        out := new(Empty)
        err := c.cc.Invoke(ctx, "/featureform.serving.metadata.proto.Metadata/CreateTrainingSetVariant", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *metadataClient) GetTrainingSets(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetTrainingSetsClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[7], "/featureform.serving.metadata.proto.Metadata/GetTrainingSets", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataGetTrainingSetsClient{stream}
        return x, nil</span>
}

type Metadata_GetTrainingSetsClient interface {
        Send(*Name) error
        Recv() (*TrainingSet, error)
        grpc.ClientStream
}

type metadataGetTrainingSetsClient struct {
        grpc.ClientStream
}

func (x *metadataGetTrainingSetsClient) Send(m *Name) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *metadataGetTrainingSetsClient) Recv() (*TrainingSet, error) <span class="cov0" title="0">{
        m := new(TrainingSet)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) GetTrainingSetVariants(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetTrainingSetVariantsClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[8], "/featureform.serving.metadata.proto.Metadata/GetTrainingSetVariants", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataGetTrainingSetVariantsClient{stream}
        return x, nil</span>
}

type Metadata_GetTrainingSetVariantsClient interface {
        Send(*NameVariant) error
        Recv() (*TrainingSetVariant, error)
        grpc.ClientStream
}

type metadataGetTrainingSetVariantsClient struct {
        grpc.ClientStream
}

func (x *metadataGetTrainingSetVariantsClient) Send(m *NameVariant) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *metadataGetTrainingSetVariantsClient) Recv() (*TrainingSetVariant, error) <span class="cov0" title="0">{
        m := new(TrainingSetVariant)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) ListSources(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListSourcesClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[9], "/featureform.serving.metadata.proto.Metadata/ListSources", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataListSourcesClient{stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

type Metadata_ListSourcesClient interface {
        Recv() (*Source, error)
        grpc.ClientStream
}

type metadataListSourcesClient struct {
        grpc.ClientStream
}

func (x *metadataListSourcesClient) Recv() (*Source, error) <span class="cov0" title="0">{
        m := new(Source)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) CreateSourceVariant(ctx context.Context, in *SourceVariant, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        out := new(Empty)
        err := c.cc.Invoke(ctx, "/featureform.serving.metadata.proto.Metadata/CreateSourceVariant", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *metadataClient) GetSources(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetSourcesClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[10], "/featureform.serving.metadata.proto.Metadata/GetSources", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataGetSourcesClient{stream}
        return x, nil</span>
}

type Metadata_GetSourcesClient interface {
        Send(*Name) error
        Recv() (*Source, error)
        grpc.ClientStream
}

type metadataGetSourcesClient struct {
        grpc.ClientStream
}

func (x *metadataGetSourcesClient) Send(m *Name) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *metadataGetSourcesClient) Recv() (*Source, error) <span class="cov0" title="0">{
        m := new(Source)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) GetSourceVariants(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetSourceVariantsClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[11], "/featureform.serving.metadata.proto.Metadata/GetSourceVariants", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataGetSourceVariantsClient{stream}
        return x, nil</span>
}

type Metadata_GetSourceVariantsClient interface {
        Send(*NameVariant) error
        Recv() (*SourceVariant, error)
        grpc.ClientStream
}

type metadataGetSourceVariantsClient struct {
        grpc.ClientStream
}

func (x *metadataGetSourceVariantsClient) Send(m *NameVariant) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *metadataGetSourceVariantsClient) Recv() (*SourceVariant, error) <span class="cov0" title="0">{
        m := new(SourceVariant)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) ListUsers(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListUsersClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[12], "/featureform.serving.metadata.proto.Metadata/ListUsers", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataListUsersClient{stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

type Metadata_ListUsersClient interface {
        Recv() (*User, error)
        grpc.ClientStream
}

type metadataListUsersClient struct {
        grpc.ClientStream
}

func (x *metadataListUsersClient) Recv() (*User, error) <span class="cov0" title="0">{
        m := new(User)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) CreateUser(ctx context.Context, in *User, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        out := new(Empty)
        err := c.cc.Invoke(ctx, "/featureform.serving.metadata.proto.Metadata/CreateUser", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *metadataClient) GetUsers(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetUsersClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[13], "/featureform.serving.metadata.proto.Metadata/GetUsers", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataGetUsersClient{stream}
        return x, nil</span>
}

type Metadata_GetUsersClient interface {
        Send(*Name) error
        Recv() (*User, error)
        grpc.ClientStream
}

type metadataGetUsersClient struct {
        grpc.ClientStream
}

func (x *metadataGetUsersClient) Send(m *Name) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *metadataGetUsersClient) Recv() (*User, error) <span class="cov0" title="0">{
        m := new(User)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) ListProviders(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListProvidersClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[14], "/featureform.serving.metadata.proto.Metadata/ListProviders", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataListProvidersClient{stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

type Metadata_ListProvidersClient interface {
        Recv() (*Provider, error)
        grpc.ClientStream
}

type metadataListProvidersClient struct {
        grpc.ClientStream
}

func (x *metadataListProvidersClient) Recv() (*Provider, error) <span class="cov0" title="0">{
        m := new(Provider)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) CreateProvider(ctx context.Context, in *Provider, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        out := new(Empty)
        err := c.cc.Invoke(ctx, "/featureform.serving.metadata.proto.Metadata/CreateProvider", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *metadataClient) GetProviders(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetProvidersClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[15], "/featureform.serving.metadata.proto.Metadata/GetProviders", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataGetProvidersClient{stream}
        return x, nil</span>
}

type Metadata_GetProvidersClient interface {
        Send(*Name) error
        Recv() (*Provider, error)
        grpc.ClientStream
}

type metadataGetProvidersClient struct {
        grpc.ClientStream
}

func (x *metadataGetProvidersClient) Send(m *Name) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *metadataGetProvidersClient) Recv() (*Provider, error) <span class="cov0" title="0">{
        m := new(Provider)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) ListEntities(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListEntitiesClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[16], "/featureform.serving.metadata.proto.Metadata/ListEntities", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataListEntitiesClient{stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

type Metadata_ListEntitiesClient interface {
        Recv() (*Entity, error)
        grpc.ClientStream
}

type metadataListEntitiesClient struct {
        grpc.ClientStream
}

func (x *metadataListEntitiesClient) Recv() (*Entity, error) <span class="cov0" title="0">{
        m := new(Entity)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) CreateEntity(ctx context.Context, in *Entity, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        out := new(Empty)
        err := c.cc.Invoke(ctx, "/featureform.serving.metadata.proto.Metadata/CreateEntity", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *metadataClient) GetEntities(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetEntitiesClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[17], "/featureform.serving.metadata.proto.Metadata/GetEntities", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataGetEntitiesClient{stream}
        return x, nil</span>
}

type Metadata_GetEntitiesClient interface {
        Send(*Name) error
        Recv() (*Entity, error)
        grpc.ClientStream
}

type metadataGetEntitiesClient struct {
        grpc.ClientStream
}

func (x *metadataGetEntitiesClient) Send(m *Name) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *metadataGetEntitiesClient) Recv() (*Entity, error) <span class="cov0" title="0">{
        m := new(Entity)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) ListModels(ctx context.Context, in *Empty, opts ...grpc.CallOption) (Metadata_ListModelsClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[18], "/featureform.serving.metadata.proto.Metadata/ListModels", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataListModelsClient{stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

type Metadata_ListModelsClient interface {
        Recv() (*Model, error)
        grpc.ClientStream
}

type metadataListModelsClient struct {
        grpc.ClientStream
}

func (x *metadataListModelsClient) Recv() (*Model, error) <span class="cov0" title="0">{
        m := new(Model)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *metadataClient) CreateModel(ctx context.Context, in *Model, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        out := new(Empty)
        err := c.cc.Invoke(ctx, "/featureform.serving.metadata.proto.Metadata/CreateModel", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *metadataClient) GetModels(ctx context.Context, opts ...grpc.CallOption) (Metadata_GetModelsClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Metadata_ServiceDesc.Streams[19], "/featureform.serving.metadata.proto.Metadata/GetModels", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;metadataGetModelsClient{stream}
        return x, nil</span>
}

type Metadata_GetModelsClient interface {
        Send(*Name) error
        Recv() (*Model, error)
        grpc.ClientStream
}

type metadataGetModelsClient struct {
        grpc.ClientStream
}

func (x *metadataGetModelsClient) Send(m *Name) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *metadataGetModelsClient) Recv() (*Model, error) <span class="cov0" title="0">{
        m := new(Model)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// MetadataServer is the server API for Metadata service.
// All implementations must embed UnimplementedMetadataServer
// for forward compatibility
type MetadataServer interface {
        ListFeatures(*Empty, Metadata_ListFeaturesServer) error
        CreateFeatureVariant(context.Context, *FeatureVariant) (*Empty, error)
        GetFeatures(Metadata_GetFeaturesServer) error
        GetFeatureVariants(Metadata_GetFeatureVariantsServer) error
        ListLabels(*Empty, Metadata_ListLabelsServer) error
        CreateLabelVariant(context.Context, *LabelVariant) (*Empty, error)
        GetLabels(Metadata_GetLabelsServer) error
        GetLabelVariants(Metadata_GetLabelVariantsServer) error
        ListTrainingSets(*Empty, Metadata_ListTrainingSetsServer) error
        CreateTrainingSetVariant(context.Context, *TrainingSetVariant) (*Empty, error)
        GetTrainingSets(Metadata_GetTrainingSetsServer) error
        GetTrainingSetVariants(Metadata_GetTrainingSetVariantsServer) error
        ListSources(*Empty, Metadata_ListSourcesServer) error
        CreateSourceVariant(context.Context, *SourceVariant) (*Empty, error)
        GetSources(Metadata_GetSourcesServer) error
        GetSourceVariants(Metadata_GetSourceVariantsServer) error
        ListUsers(*Empty, Metadata_ListUsersServer) error
        CreateUser(context.Context, *User) (*Empty, error)
        GetUsers(Metadata_GetUsersServer) error
        ListProviders(*Empty, Metadata_ListProvidersServer) error
        CreateProvider(context.Context, *Provider) (*Empty, error)
        GetProviders(Metadata_GetProvidersServer) error
        ListEntities(*Empty, Metadata_ListEntitiesServer) error
        CreateEntity(context.Context, *Entity) (*Empty, error)
        GetEntities(Metadata_GetEntitiesServer) error
        ListModels(*Empty, Metadata_ListModelsServer) error
        CreateModel(context.Context, *Model) (*Empty, error)
        GetModels(Metadata_GetModelsServer) error
        mustEmbedUnimplementedMetadataServer()
}

// UnimplementedMetadataServer must be embedded to have forward compatible implementations.
type UnimplementedMetadataServer struct {
}

func (UnimplementedMetadataServer) ListFeatures(*Empty, Metadata_ListFeaturesServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method ListFeatures not implemented")
}</span>
func (UnimplementedMetadataServer) CreateFeatureVariant(context.Context, *FeatureVariant) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateFeatureVariant not implemented")
}</span>
func (UnimplementedMetadataServer) GetFeatures(Metadata_GetFeaturesServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method GetFeatures not implemented")
}</span>
func (UnimplementedMetadataServer) GetFeatureVariants(Metadata_GetFeatureVariantsServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method GetFeatureVariants not implemented")
}</span>
func (UnimplementedMetadataServer) ListLabels(*Empty, Metadata_ListLabelsServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method ListLabels not implemented")
}</span>
func (UnimplementedMetadataServer) CreateLabelVariant(context.Context, *LabelVariant) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateLabelVariant not implemented")
}</span>
func (UnimplementedMetadataServer) GetLabels(Metadata_GetLabelsServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method GetLabels not implemented")
}</span>
func (UnimplementedMetadataServer) GetLabelVariants(Metadata_GetLabelVariantsServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method GetLabelVariants not implemented")
}</span>
func (UnimplementedMetadataServer) ListTrainingSets(*Empty, Metadata_ListTrainingSetsServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method ListTrainingSets not implemented")
}</span>
func (UnimplementedMetadataServer) CreateTrainingSetVariant(context.Context, *TrainingSetVariant) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateTrainingSetVariant not implemented")
}</span>
func (UnimplementedMetadataServer) GetTrainingSets(Metadata_GetTrainingSetsServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method GetTrainingSets not implemented")
}</span>
func (UnimplementedMetadataServer) GetTrainingSetVariants(Metadata_GetTrainingSetVariantsServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method GetTrainingSetVariants not implemented")
}</span>
func (UnimplementedMetadataServer) ListSources(*Empty, Metadata_ListSourcesServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method ListSources not implemented")
}</span>
func (UnimplementedMetadataServer) CreateSourceVariant(context.Context, *SourceVariant) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateSourceVariant not implemented")
}</span>
func (UnimplementedMetadataServer) GetSources(Metadata_GetSourcesServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method GetSources not implemented")
}</span>
func (UnimplementedMetadataServer) GetSourceVariants(Metadata_GetSourceVariantsServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method GetSourceVariants not implemented")
}</span>
func (UnimplementedMetadataServer) ListUsers(*Empty, Metadata_ListUsersServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
}</span>
func (UnimplementedMetadataServer) CreateUser(context.Context, *User) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}</span>
func (UnimplementedMetadataServer) GetUsers(Metadata_GetUsersServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method GetUsers not implemented")
}</span>
func (UnimplementedMetadataServer) ListProviders(*Empty, Metadata_ListProvidersServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method ListProviders not implemented")
}</span>
func (UnimplementedMetadataServer) CreateProvider(context.Context, *Provider) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateProvider not implemented")
}</span>
func (UnimplementedMetadataServer) GetProviders(Metadata_GetProvidersServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method GetProviders not implemented")
}</span>
func (UnimplementedMetadataServer) ListEntities(*Empty, Metadata_ListEntitiesServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method ListEntities not implemented")
}</span>
func (UnimplementedMetadataServer) CreateEntity(context.Context, *Entity) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateEntity not implemented")
}</span>
func (UnimplementedMetadataServer) GetEntities(Metadata_GetEntitiesServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method GetEntities not implemented")
}</span>
func (UnimplementedMetadataServer) ListModels(*Empty, Metadata_ListModelsServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method ListModels not implemented")
}</span>
func (UnimplementedMetadataServer) CreateModel(context.Context, *Model) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method CreateModel not implemented")
}</span>
func (UnimplementedMetadataServer) GetModels(Metadata_GetModelsServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method GetModels not implemented")
}</span>
func (UnimplementedMetadataServer) mustEmbedUnimplementedMetadataServer() {<span class="cov0" title="0">}</span>

// UnsafeMetadataServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MetadataServer will
// result in compilation errors.
type UnsafeMetadataServer interface {
        mustEmbedUnimplementedMetadataServer()
}

func RegisterMetadataServer(s grpc.ServiceRegistrar, srv MetadataServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;Metadata_ServiceDesc, srv)
}</span>

func _Metadata_ListFeatures_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(Empty)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(MetadataServer).ListFeatures(m, &amp;metadataListFeaturesServer{stream})</span>
}

type Metadata_ListFeaturesServer interface {
        Send(*Feature) error
        grpc.ServerStream
}

type metadataListFeaturesServer struct {
        grpc.ServerStream
}

func (x *metadataListFeaturesServer) Send(m *Feature) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func _Metadata_CreateFeatureVariant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(FeatureVariant)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateFeatureVariant(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/featureform.serving.metadata.proto.Metadata/CreateFeatureVariant",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateFeatureVariant(ctx, req.(*FeatureVariant))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Metadata_GetFeatures_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(MetadataServer).GetFeatures(&amp;metadataGetFeaturesServer{stream})
}</span>

type Metadata_GetFeaturesServer interface {
        Send(*Feature) error
        Recv() (*Name, error)
        grpc.ServerStream
}

type metadataGetFeaturesServer struct {
        grpc.ServerStream
}

func (x *metadataGetFeaturesServer) Send(m *Feature) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *metadataGetFeaturesServer) Recv() (*Name, error) <span class="cov0" title="0">{
        m := new(Name)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func _Metadata_GetFeatureVariants_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(MetadataServer).GetFeatureVariants(&amp;metadataGetFeatureVariantsServer{stream})
}</span>

type Metadata_GetFeatureVariantsServer interface {
        Send(*FeatureVariant) error
        Recv() (*NameVariant, error)
        grpc.ServerStream
}

type metadataGetFeatureVariantsServer struct {
        grpc.ServerStream
}

func (x *metadataGetFeatureVariantsServer) Send(m *FeatureVariant) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *metadataGetFeatureVariantsServer) Recv() (*NameVariant, error) <span class="cov0" title="0">{
        m := new(NameVariant)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func _Metadata_ListLabels_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(Empty)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(MetadataServer).ListLabels(m, &amp;metadataListLabelsServer{stream})</span>
}

type Metadata_ListLabelsServer interface {
        Send(*Label) error
        grpc.ServerStream
}

type metadataListLabelsServer struct {
        grpc.ServerStream
}

func (x *metadataListLabelsServer) Send(m *Label) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func _Metadata_CreateLabelVariant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LabelVariant)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateLabelVariant(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/featureform.serving.metadata.proto.Metadata/CreateLabelVariant",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateLabelVariant(ctx, req.(*LabelVariant))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Metadata_GetLabels_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(MetadataServer).GetLabels(&amp;metadataGetLabelsServer{stream})
}</span>

type Metadata_GetLabelsServer interface {
        Send(*Label) error
        Recv() (*Name, error)
        grpc.ServerStream
}

type metadataGetLabelsServer struct {
        grpc.ServerStream
}

func (x *metadataGetLabelsServer) Send(m *Label) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *metadataGetLabelsServer) Recv() (*Name, error) <span class="cov0" title="0">{
        m := new(Name)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func _Metadata_GetLabelVariants_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(MetadataServer).GetLabelVariants(&amp;metadataGetLabelVariantsServer{stream})
}</span>

type Metadata_GetLabelVariantsServer interface {
        Send(*LabelVariant) error
        Recv() (*NameVariant, error)
        grpc.ServerStream
}

type metadataGetLabelVariantsServer struct {
        grpc.ServerStream
}

func (x *metadataGetLabelVariantsServer) Send(m *LabelVariant) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *metadataGetLabelVariantsServer) Recv() (*NameVariant, error) <span class="cov0" title="0">{
        m := new(NameVariant)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func _Metadata_ListTrainingSets_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(Empty)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(MetadataServer).ListTrainingSets(m, &amp;metadataListTrainingSetsServer{stream})</span>
}

type Metadata_ListTrainingSetsServer interface {
        Send(*TrainingSet) error
        grpc.ServerStream
}

type metadataListTrainingSetsServer struct {
        grpc.ServerStream
}

func (x *metadataListTrainingSetsServer) Send(m *TrainingSet) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func _Metadata_CreateTrainingSetVariant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(TrainingSetVariant)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateTrainingSetVariant(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/featureform.serving.metadata.proto.Metadata/CreateTrainingSetVariant",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateTrainingSetVariant(ctx, req.(*TrainingSetVariant))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Metadata_GetTrainingSets_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(MetadataServer).GetTrainingSets(&amp;metadataGetTrainingSetsServer{stream})
}</span>

type Metadata_GetTrainingSetsServer interface {
        Send(*TrainingSet) error
        Recv() (*Name, error)
        grpc.ServerStream
}

type metadataGetTrainingSetsServer struct {
        grpc.ServerStream
}

func (x *metadataGetTrainingSetsServer) Send(m *TrainingSet) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *metadataGetTrainingSetsServer) Recv() (*Name, error) <span class="cov0" title="0">{
        m := new(Name)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func _Metadata_GetTrainingSetVariants_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(MetadataServer).GetTrainingSetVariants(&amp;metadataGetTrainingSetVariantsServer{stream})
}</span>

type Metadata_GetTrainingSetVariantsServer interface {
        Send(*TrainingSetVariant) error
        Recv() (*NameVariant, error)
        grpc.ServerStream
}

type metadataGetTrainingSetVariantsServer struct {
        grpc.ServerStream
}

func (x *metadataGetTrainingSetVariantsServer) Send(m *TrainingSetVariant) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *metadataGetTrainingSetVariantsServer) Recv() (*NameVariant, error) <span class="cov0" title="0">{
        m := new(NameVariant)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func _Metadata_ListSources_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(Empty)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(MetadataServer).ListSources(m, &amp;metadataListSourcesServer{stream})</span>
}

type Metadata_ListSourcesServer interface {
        Send(*Source) error
        grpc.ServerStream
}

type metadataListSourcesServer struct {
        grpc.ServerStream
}

func (x *metadataListSourcesServer) Send(m *Source) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func _Metadata_CreateSourceVariant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(SourceVariant)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateSourceVariant(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/featureform.serving.metadata.proto.Metadata/CreateSourceVariant",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateSourceVariant(ctx, req.(*SourceVariant))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Metadata_GetSources_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(MetadataServer).GetSources(&amp;metadataGetSourcesServer{stream})
}</span>

type Metadata_GetSourcesServer interface {
        Send(*Source) error
        Recv() (*Name, error)
        grpc.ServerStream
}

type metadataGetSourcesServer struct {
        grpc.ServerStream
}

func (x *metadataGetSourcesServer) Send(m *Source) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *metadataGetSourcesServer) Recv() (*Name, error) <span class="cov0" title="0">{
        m := new(Name)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func _Metadata_GetSourceVariants_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(MetadataServer).GetSourceVariants(&amp;metadataGetSourceVariantsServer{stream})
}</span>

type Metadata_GetSourceVariantsServer interface {
        Send(*SourceVariant) error
        Recv() (*NameVariant, error)
        grpc.ServerStream
}

type metadataGetSourceVariantsServer struct {
        grpc.ServerStream
}

func (x *metadataGetSourceVariantsServer) Send(m *SourceVariant) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *metadataGetSourceVariantsServer) Recv() (*NameVariant, error) <span class="cov0" title="0">{
        m := new(NameVariant)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func _Metadata_ListUsers_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(Empty)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(MetadataServer).ListUsers(m, &amp;metadataListUsersServer{stream})</span>
}

type Metadata_ListUsersServer interface {
        Send(*User) error
        grpc.ServerStream
}

type metadataListUsersServer struct {
        grpc.ServerStream
}

func (x *metadataListUsersServer) Send(m *User) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func _Metadata_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(User)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateUser(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/featureform.serving.metadata.proto.Metadata/CreateUser",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateUser(ctx, req.(*User))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Metadata_GetUsers_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(MetadataServer).GetUsers(&amp;metadataGetUsersServer{stream})
}</span>

type Metadata_GetUsersServer interface {
        Send(*User) error
        Recv() (*Name, error)
        grpc.ServerStream
}

type metadataGetUsersServer struct {
        grpc.ServerStream
}

func (x *metadataGetUsersServer) Send(m *User) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *metadataGetUsersServer) Recv() (*Name, error) <span class="cov0" title="0">{
        m := new(Name)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func _Metadata_ListProviders_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(Empty)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(MetadataServer).ListProviders(m, &amp;metadataListProvidersServer{stream})</span>
}

type Metadata_ListProvidersServer interface {
        Send(*Provider) error
        grpc.ServerStream
}

type metadataListProvidersServer struct {
        grpc.ServerStream
}

func (x *metadataListProvidersServer) Send(m *Provider) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func _Metadata_CreateProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(Provider)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateProvider(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/featureform.serving.metadata.proto.Metadata/CreateProvider",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateProvider(ctx, req.(*Provider))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Metadata_GetProviders_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(MetadataServer).GetProviders(&amp;metadataGetProvidersServer{stream})
}</span>

type Metadata_GetProvidersServer interface {
        Send(*Provider) error
        Recv() (*Name, error)
        grpc.ServerStream
}

type metadataGetProvidersServer struct {
        grpc.ServerStream
}

func (x *metadataGetProvidersServer) Send(m *Provider) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *metadataGetProvidersServer) Recv() (*Name, error) <span class="cov0" title="0">{
        m := new(Name)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func _Metadata_ListEntities_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(Empty)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(MetadataServer).ListEntities(m, &amp;metadataListEntitiesServer{stream})</span>
}

type Metadata_ListEntitiesServer interface {
        Send(*Entity) error
        grpc.ServerStream
}

type metadataListEntitiesServer struct {
        grpc.ServerStream
}

func (x *metadataListEntitiesServer) Send(m *Entity) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func _Metadata_CreateEntity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(Entity)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateEntity(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/featureform.serving.metadata.proto.Metadata/CreateEntity",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateEntity(ctx, req.(*Entity))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Metadata_GetEntities_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(MetadataServer).GetEntities(&amp;metadataGetEntitiesServer{stream})
}</span>

type Metadata_GetEntitiesServer interface {
        Send(*Entity) error
        Recv() (*Name, error)
        grpc.ServerStream
}

type metadataGetEntitiesServer struct {
        grpc.ServerStream
}

func (x *metadataGetEntitiesServer) Send(m *Entity) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *metadataGetEntitiesServer) Recv() (*Name, error) <span class="cov0" title="0">{
        m := new(Name)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func _Metadata_ListModels_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(Empty)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(MetadataServer).ListModels(m, &amp;metadataListModelsServer{stream})</span>
}

type Metadata_ListModelsServer interface {
        Send(*Model) error
        grpc.ServerStream
}

type metadataListModelsServer struct {
        grpc.ServerStream
}

func (x *metadataListModelsServer) Send(m *Model) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func _Metadata_CreateModel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(Model)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateModel(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/featureform.serving.metadata.proto.Metadata/CreateModel",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(MetadataServer).CreateModel(ctx, req.(*Model))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _Metadata_GetModels_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(MetadataServer).GetModels(&amp;metadataGetModelsServer{stream})
}</span>

type Metadata_GetModelsServer interface {
        Send(*Model) error
        Recv() (*Name, error)
        grpc.ServerStream
}

type metadataGetModelsServer struct {
        grpc.ServerStream
}

func (x *metadataGetModelsServer) Send(m *Model) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *metadataGetModelsServer) Recv() (*Name, error) <span class="cov0" title="0">{
        m := new(Name)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// Metadata_ServiceDesc is the grpc.ServiceDesc for Metadata service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Metadata_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "featureform.serving.metadata.proto.Metadata",
        HandlerType: (*MetadataServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "CreateFeatureVariant",
                        Handler:    _Metadata_CreateFeatureVariant_Handler,
                },
                {
                        MethodName: "CreateLabelVariant",
                        Handler:    _Metadata_CreateLabelVariant_Handler,
                },
                {
                        MethodName: "CreateTrainingSetVariant",
                        Handler:    _Metadata_CreateTrainingSetVariant_Handler,
                },
                {
                        MethodName: "CreateSourceVariant",
                        Handler:    _Metadata_CreateSourceVariant_Handler,
                },
                {
                        MethodName: "CreateUser",
                        Handler:    _Metadata_CreateUser_Handler,
                },
                {
                        MethodName: "CreateProvider",
                        Handler:    _Metadata_CreateProvider_Handler,
                },
                {
                        MethodName: "CreateEntity",
                        Handler:    _Metadata_CreateEntity_Handler,
                },
                {
                        MethodName: "CreateModel",
                        Handler:    _Metadata_CreateModel_Handler,
                },
        },
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "ListFeatures",
                        Handler:       _Metadata_ListFeatures_Handler,
                        ServerStreams: true,
                },
                {
                        StreamName:    "GetFeatures",
                        Handler:       _Metadata_GetFeatures_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
                {
                        StreamName:    "GetFeatureVariants",
                        Handler:       _Metadata_GetFeatureVariants_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
                {
                        StreamName:    "ListLabels",
                        Handler:       _Metadata_ListLabels_Handler,
                        ServerStreams: true,
                },
                {
                        StreamName:    "GetLabels",
                        Handler:       _Metadata_GetLabels_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
                {
                        StreamName:    "GetLabelVariants",
                        Handler:       _Metadata_GetLabelVariants_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
                {
                        StreamName:    "ListTrainingSets",
                        Handler:       _Metadata_ListTrainingSets_Handler,
                        ServerStreams: true,
                },
                {
                        StreamName:    "GetTrainingSets",
                        Handler:       _Metadata_GetTrainingSets_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
                {
                        StreamName:    "GetTrainingSetVariants",
                        Handler:       _Metadata_GetTrainingSetVariants_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
                {
                        StreamName:    "ListSources",
                        Handler:       _Metadata_ListSources_Handler,
                        ServerStreams: true,
                },
                {
                        StreamName:    "GetSources",
                        Handler:       _Metadata_GetSources_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
                {
                        StreamName:    "GetSourceVariants",
                        Handler:       _Metadata_GetSourceVariants_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
                {
                        StreamName:    "ListUsers",
                        Handler:       _Metadata_ListUsers_Handler,
                        ServerStreams: true,
                },
                {
                        StreamName:    "GetUsers",
                        Handler:       _Metadata_GetUsers_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
                {
                        StreamName:    "ListProviders",
                        Handler:       _Metadata_ListProviders_Handler,
                        ServerStreams: true,
                },
                {
                        StreamName:    "GetProviders",
                        Handler:       _Metadata_GetProviders_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
                {
                        StreamName:    "ListEntities",
                        Handler:       _Metadata_ListEntities_Handler,
                        ServerStreams: true,
                },
                {
                        StreamName:    "GetEntities",
                        Handler:       _Metadata_GetEntities_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
                {
                        StreamName:    "ListModels",
                        Handler:       _Metadata_ListModels_Handler,
                        ServerStreams: true,
                },
                {
                        StreamName:    "GetModels",
                        Handler:       _Metadata_GetModels_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
        },
        Metadata: "metadata/proto/metadata.proto",
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package search

import (
        "fmt"

        "github.com/typesense/typesense-go/typesense"
        "github.com/typesense/typesense-go/typesense/api"
)

type Searcher interface {
        Upsert(ResourceDoc) error
        RunSearch(q string) ([]ResourceDoc, error)
        DeleteAll() error
}

type TypeSenseParams struct {
        Host   string
        Port   string
        ApiKey string
}

type Search struct {
        client *typesense.Client
}

func NewTypesenseSearch(params *TypeSenseParams) (Searcher, error) <span class="cov8" title="1">{
        client := typesense.NewClient(
                typesense.WithServer(fmt.Sprintf("http://%s:%s", params.Host, params.Port)),
                typesense.WithAPIKey(params.ApiKey))
        if _, errRetr := client.Collection("resource").Retrieve(); errRetr != nil </span><span class="cov8" title="1">{
                errHttp, isHttpErr := errRetr.(*typesense.HTTPError)
                schemaNotFound := isHttpErr &amp;&amp; errHttp.Status == 404
                if schemaNotFound </span><span class="cov0" title="0">{
                        if err := makeSchema(client); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                } else<span class="cov8" title="1"> {
                        return nil, errRetr
                }</span>
        }
        <span class="cov0" title="0">if err := initializeCollection(client); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Search{
                client: client,
        }, nil</span>
}

type ResourceDoc struct {
        Name    string
        Variant string
        Type    string
}

func makeSchema(client *typesense.Client) error <span class="cov0" title="0">{
        schema := &amp;api.CollectionSchema{
                Name: "resource",
                Fields: []api.Field{
                        {
                                Name: "Name",
                                Type: "string",
                        },
                        {
                                Name: "Variant",
                                Type: "string",
                        },
                        {
                                Name: "Type",
                                Type: "string",
                        },
                },
                TokenSeparators: &amp;[]string{
                        "-",
                        "_",
                },
        }
        _, err := client.Collections().Create(schema)
        return err
}</span>

func initializeCollection(client *typesense.Client) error <span class="cov0" title="0">{
        var resourceinitial []interface{}
        var resourceempty ResourceDoc
        resourceinitial = append(resourceinitial, resourceempty)
        action := "create"
        batchnum := 40
        params := &amp;api.ImportDocumentsParams{
                Action:    &amp;action,
                BatchSize: &amp;batchnum,
        }
        //initializing resource collection with empty struct so we can use upsert function
        _, err := client.Collection("resource").Documents().Import(resourceinitial, params)
        return err
}</span>

func (s Search) Upsert(doc ResourceDoc) error <span class="cov0" title="0">{
        _, err := s.client.Collection("resource").Documents().Upsert(doc)
        return err
}</span>

func (s Search) DeleteAll() error <span class="cov0" title="0">{
        if _, err := s.client.Collection("resource").Delete(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return makeSchema(s.client)</span>
}

func (s Search) RunSearch(q string) ([]ResourceDoc, error) <span class="cov0" title="0">{
        searchParameters := &amp;api.SearchCollectionParams{
                Q:       q,
                QueryBy: "Name",
        }
        results, errGetResults := s.client.Collection("resource").Documents().Search(searchParameters)
        if errGetResults != nil </span><span class="cov0" title="0">{
                return nil, errGetResults
        }</span>
        <span class="cov0" title="0">var searchresults []ResourceDoc
        for _, hit := range *results.Hits </span><span class="cov0" title="0">{
                doc := *hit.Document
                searchresults = append(searchresults, ResourceDoc{
                        Name:    doc["Name"].(string),
                        Type:    doc["Type"].(string),
                        Variant: doc["Variant"].(string),
                })
        }</span>
        <span class="cov0" title="0">return searchresults, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package main

import (
        "net"

        "github.com/featureform/serving/metadata"
        pb "github.com/featureform/serving/metadata/proto"
        "go.uber.org/zap"
        "google.golang.org/grpc"
)

func main() <span class="cov0" title="0">{
        logger := zap.NewExample().Sugar()
        port := ":8080"
        lis, err := net.Listen("tcp", port)
        config := &amp;metadata.Config{
                Logger: logger,
                //TypeSenseParams: &amp;search.TypeSenseParams{
                //        Port:   "8108",
                //        Host:   "localhost",
                //        ApiKey: "xyz",
                //},
        }
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicw("Failed to listen on port", "Err", err)
        }</span>
        <span class="cov0" title="0">grpcServer := grpc.NewServer()
        server, err := metadata.NewMetadataServer(config)
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicw("Failed to create metadata server", "Err", err)
        }</span>
        <span class="cov0" title="0">pb.RegisterMetadataServer(grpcServer, server)

        logger.Infow("Server starting", "Port", port)
        serveErr := grpcServer.Serve(lis)
        if serveErr != nil </span><span class="cov0" title="0">{
                logger.Errorw("Serve failed with error", "Err", serveErr)
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package metrics

import (
        "fmt"
        "log"
        "net/http"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

//generic interfaces exposed to the user
type MetricsHandler interface {
        BeginObservingOnlineServe(feature string, key string) FeatureObserver
        BeginObservingTrainingServe(name string, version string) FeatureObserver
        ExposePort(port string)
}

type FeatureObserver interface {
        SetError()
        ServeRow()
        Finish()
}

type PromMetricsHandler struct {
        Hist  *prometheus.HistogramVec
        Count *prometheus.CounterVec
        Name  string
}

type PromFeatureObserver struct {
        Timer   *prometheus.Timer
        Count   *prometheus.CounterVec
        Name    string
        Feature string
        Key     string
        Status  string
}

type TrainingDataObserver struct {
        Timer     *prometheus.Timer
        Row_Count *prometheus.CounterVec
        Timestamp string
        Title     string
        Name      string
        Version   string
        Status    string
}

func NewMetrics(name string) PromMetricsHandler <span class="cov8" title="1">{
        var getFeatureCounter = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: fmt.Sprintf("%s_counter", name), // metric name
                        Help: "Counter for feature serve requests, labeled by feature name, key and type",
                },
                []string{"instance", "feature", "key", "status"}, // labels
        )

        var getFeatureLatency = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    fmt.Sprintf("%s_duration_seconds", name),
                        Help:    "Latency for feature serve requests, labeled by feature name, key and type",
                        Buckets: prometheus.LinearBuckets(0.01, 0.05, 10),
                },
                []string{"instance", "feature", "key", "status"}, //labels
        )

        prometheus.MustRegister(getFeatureCounter)
        prometheus.MustRegister(getFeatureLatency)
        return PromMetricsHandler{
                Hist:  getFeatureLatency,
                Count: getFeatureCounter,
                Name:  name,
        }
}</span>

func (p PromMetricsHandler) BeginObservingOnlineServe(feature string, key string) FeatureObserver <span class="cov8" title="1">{
        timer := prometheus.NewTimer(prometheus.ObserverFunc(func(v float64) </span><span class="cov8" title="1">{
                p.Hist.WithLabelValues(p.Name, feature, key, "").Observe(v)
        }</span>))
        <span class="cov8" title="1">return PromFeatureObserver{
                Timer:   timer,
                Count:   p.Count,
                Name:    p.Name,
                Feature: feature,
                Key:     key,
                Status:  "running",
        }</span>
}
func (p PromMetricsHandler) BeginObservingTrainingServe(name string, version string) FeatureObserver <span class="cov8" title="1">{
        timestamp := time.Now().UTC().Format("20060102150405")
        timer := prometheus.NewTimer(prometheus.ObserverFunc(func(v float64) </span><span class="cov8" title="1">{
                p.Hist.WithLabelValues(p.Name, name, version, "").Observe(v)
        }</span>))
        <span class="cov8" title="1">return TrainingDataObserver{
                Timer:     timer,
                Row_Count: p.Count,
                Timestamp: timestamp,
                Title:     p.Name,
                Name:      name,
                Version:   version,
                Status:    "running",
        }</span>
}

func (p PromMetricsHandler) ExposePort(port string) <span class="cov0" title="0">{
        http.Handle("/metrics", promhttp.Handler())
        log.Fatal(http.ListenAndServe(port, nil))

}</span>

func (p PromFeatureObserver) SetError() <span class="cov8" title="1">{
        p.Status="error"
        p.Timer.ObserveDuration()
        p.Count.WithLabelValues(p.Name, p.Feature, p.Key, "error").Inc()
}</span>

func (p PromFeatureObserver) ServeRow() <span class="cov8" title="1">{
        p.Count.WithLabelValues(p.Name, p.Feature, p.Key, "row serving").Inc()
}</span>

func (p PromFeatureObserver) Finish() <span class="cov8" title="1">{
        p.Status = "success"
        p.Timer.ObserveDuration()
        p.Count.WithLabelValues(p.Name, p.Feature, p.Key, "success").Inc()
}</span>

func (p TrainingDataObserver) SetError() <span class="cov8" title="1">{
        p.Status="error"
        p.Timer.ObserveDuration()
        p.Row_Count.WithLabelValues(p.Title, p.Name, p.Version, "error").Inc()
}</span>

func (p TrainingDataObserver) ServeRow() <span class="cov8" title="1">{
        p.Row_Count.WithLabelValues(p.Title, p.Name, p.Version,"row serve").Inc()
}</span>

func (p TrainingDataObserver) Finish() <span class="cov8" title="1">{
        p.Status = "success"
        p.Timer.ObserveDuration()
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package main

import (
        "fmt"

        "github.com/featureform/serving/dataset"
)

type featureId struct {
        Name    string
        Version string
}

type MemoryOnlineProvider struct {
        tables map[featureId]featureTable
}

func NewMemoryOnlineProvider() *MemoryOnlineProvider <span class="cov0" title="0">{
        return &amp;MemoryOnlineProvider{
                tables: make(map[featureId]featureTable),
        }
}</span>

type featureTable map[string]interface{}

func (table featureTable) Get(entity string) (*dataset.Feature, error) <span class="cov0" title="0">{
        val, has := table[entity]
        if !has </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Entity not found: %s", entity)
        }</span>
        <span class="cov0" title="0">return dataset.NewFeature(val)</span>
}

func (provider *MemoryOnlineProvider) ToKey(name, version string) map[string]string <span class="cov0" title="0">{
        return map[string]string{
                "name":    name,
                "version": version,
        }
}</span>

func (provider *MemoryOnlineProvider) SetFeature(name, version, entity string, value interface{}) <span class="cov0" title="0">{
        id := featureId{name, version}
        features, has := provider.tables[id]
        if !has </span><span class="cov0" title="0">{
                features = make(featureTable)
                provider.tables[id] = features
        }</span>
        <span class="cov0" title="0">features[entity] = value</span>
}

func (provider *MemoryOnlineProvider) GetFeatureLookup(key map[string]string) (dataset.Lookup, error) <span class="cov0" title="0">{
        id := featureId{key["name"], key["version"]}
        lookup, has := provider.tables[id]
        if !has </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Feature not found: %s %s", key["name"], key["version"])
        }</span>
        <span class="cov0" title="0">return lookup, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "net/url"
        "strings"

        "github.com/featureform/serving/dataset"
        "github.com/lib/pq"
        "go.uber.org/zap"
)

type Provider struct {
        Logger *zap.SugaredLogger
        DB     *sql.DB
}

type ConnectionParams struct {
        User, Password, DBName, Host string
        Port                         int
        Mode                         VerifyMode
}

type VerifyMode string

const (
        Disable    VerifyMode = "disable"
        Require               = "require"
        VerifyCA              = "verify-ca"
        VerifyFull            = "verify-full"
)

func (params *ConnectionParams) urlString() string <span class="cov8" title="1">{
        if params.Port == 0 </span><span class="cov8" title="1">{
                params.Port = 5432
        }</span>
        <span class="cov8" title="1">if params.Mode == "" </span><span class="cov8" title="1">{
                params.Mode = Disable
        }</span>
        <span class="cov8" title="1">hostStr := fmt.Sprintf("%s:%d", params.Host, params.Port)
        qry := url.Values{}
        qry.Set("sslmode", string(params.Mode))
        uri := &amp;url.URL{
                Scheme:   "postgres",
                User:     url.UserPassword(params.User, params.Password),
                Host:     hostStr,
                Path:     params.DBName,
                RawQuery: qry.Encode(),
        }
        return uri.String()</span>
}

func NewProvider(params ConnectionParams, logger *zap.SugaredLogger) (*Provider, error) <span class="cov0" title="0">{
        connLogger := logger.With("Connection", params.Host)
        connLogger.Info("Opening SQL connection")
        db, err := sql.Open("postgres", params.urlString())
        if err != nil </span><span class="cov0" title="0">{
                connLogger.Error("Failed to open SQL connection")
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewProviderWithDB(db, logger)</span>
}

func NewProviderWithDB(db *sql.DB, logger *zap.SugaredLogger) (*Provider, error) <span class="cov8" title="1">{
        return &amp;Provider{
                Logger: logger,
                DB:     db,
        }, nil
}</span>

func (provider *Provider) ToKey(name string, schema TableSchema) map[string]string <span class="cov8" title="1">{
        logger := provider.Logger
        key := make(map[string]string)
        key["tablename"] = name
        schemaJson, err := json.Marshal(schema)
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicw("Failed to marshal SQL schema", "Error", err)
        }</span>
        <span class="cov8" title="1">key["schema"] = string(schemaJson)
        logger.Debugw("Generated SQL key", "Key", key)
        return key</span>
}

type TableSchema struct {
        Label    string
        Features []string
}

func (provider *Provider) GetDatasetReader(key map[string]string) (dataset.Reader, error) <span class="cov8" title="1">{
        logger := provider.Logger.With("Key", key)
        bldr := strings.Builder{}
        var schema TableSchema
        err := json.Unmarshal([]byte(key["schema"]), &amp;schema)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to unmarshal schema", "Error", err)
        }</span>
        <span class="cov8" title="1">bldr.WriteString("SELECT ")
        for _, feature := range schema.Features </span><span class="cov8" title="1">{
                bldr.WriteString(pq.QuoteIdentifier(feature))
                bldr.WriteString(",")
        }</span>
        <span class="cov8" title="1">bldr.WriteString(schema.Label)
        bldr.WriteString(" FROM ")
        bldr.WriteString(pq.QuoteIdentifier(key["tablename"]))
        qry := bldr.String()
        logger = logger.With("Query", qry)
        logger.Info("Running query")
        rows, err := provider.DB.QueryContext(context.Background(), qry)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to run query", "Error", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;Dataset{
                rows:   rows,
                schema: schema}, nil</span>
}

type Dataset struct {
        rows   *sql.Rows
        schema TableSchema
        row    *dataset.Row
        err    error
}

func (ds *Dataset) Scan() bool <span class="cov8" title="1">{
        if !ds.rows.Next() </span><span class="cov8" title="1">{
                ds.err = ds.rows.Err()
                return false
        }</span>
        <span class="cov8" title="1">numFeatures := len(ds.schema.Features)
        numLabels := 1
        numValues := numFeatures + numLabels
        vals := make([]interface{}, numValues)
        indirect := make([]interface{}, numValues)
        for i := range vals </span><span class="cov8" title="1">{
                indirect[i] = &amp;vals[i]
        }</span>
        <span class="cov8" title="1">if err := ds.rows.Scan(indirect...); err != nil </span><span class="cov0" title="0">{
                ds.err = err
                return false
        }</span>
        <span class="cov8" title="1">row := dataset.NewRow()
        for i := range ds.schema.Features </span><span class="cov8" title="1">{
                if err := row.AddFeature(vals[i]); err != nil </span><span class="cov0" title="0">{
                        ds.err = err
                        return false
                }</span>
        }
        <span class="cov8" title="1">lastIdx := len(ds.schema.Features)
        if err := row.SetLabel(vals[lastIdx]); err != nil </span><span class="cov0" title="0">{
                ds.err = err
                return false
        }</span>
        <span class="cov8" title="1">ds.row = row
        return true</span>
}

func (ds *Dataset) Row() *dataset.Row <span class="cov8" title="1">{
        return ds.row
}</span>

func (ds *Dataset) Err() error <span class="cov8" title="1">{
        return ds.err
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.27.1
//         protoc        v3.19.4
// source: proto/serving.proto

package proto

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TrainingDataRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Id *TrainingDataID `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (x *TrainingDataRequest) Reset() <span class="cov0" title="0">{
        *x = TrainingDataRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_serving_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TrainingDataRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TrainingDataRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TrainingDataRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_serving_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TrainingDataRequest.ProtoReflect.Descriptor instead.
func (*TrainingDataRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_serving_proto_rawDescGZIP(), []int{0}
}</span>

func (x *TrainingDataRequest) GetId() *TrainingDataID <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Id
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type TrainingDataID struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (x *TrainingDataID) Reset() <span class="cov0" title="0">{
        *x = TrainingDataID{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_serving_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TrainingDataID) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TrainingDataID) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TrainingDataID) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_serving_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TrainingDataID.ProtoReflect.Descriptor instead.
func (*TrainingDataID) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_serving_proto_rawDescGZIP(), []int{1}
}</span>

func (x *TrainingDataID) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TrainingDataID) GetVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Version
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type TrainingDataRow struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Features []*Value `protobuf:"bytes,1,rep,name=features,proto3" json:"features,omitempty"`
        Label    *Value   `protobuf:"bytes,2,opt,name=label,proto3" json:"label,omitempty"`
}

func (x *TrainingDataRow) Reset() <span class="cov0" title="0">{
        *x = TrainingDataRow{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_serving_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TrainingDataRow) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TrainingDataRow) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TrainingDataRow) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_proto_serving_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TrainingDataRow.ProtoReflect.Descriptor instead.
func (*TrainingDataRow) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_serving_proto_rawDescGZIP(), []int{2}
}</span>

func (x *TrainingDataRow) GetFeatures() []*Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *TrainingDataRow) GetLabel() *Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Label
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FeatureServeRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Features []*FeatureID `protobuf:"bytes,1,rep,name=features,proto3" json:"features,omitempty"`
        Entities []*Entity    `protobuf:"bytes,2,rep,name=entities,proto3" json:"entities,omitempty"`
}

func (x *FeatureServeRequest) Reset() <span class="cov0" title="0">{
        *x = FeatureServeRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_serving_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureServeRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureServeRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureServeRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_serving_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureServeRequest.ProtoReflect.Descriptor instead.
func (*FeatureServeRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_serving_proto_rawDescGZIP(), []int{3}
}</span>

func (x *FeatureServeRequest) GetFeatures() []*FeatureID <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureServeRequest) GetEntities() []*Entity <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entities
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FeatureRow struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Values []*Value `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
}

func (x *FeatureRow) Reset() <span class="cov0" title="0">{
        *x = FeatureRow{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_serving_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureRow) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureRow) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureRow) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_serving_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureRow.ProtoReflect.Descriptor instead.
func (*FeatureRow) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_serving_proto_rawDescGZIP(), []int{4}
}</span>

func (x *FeatureRow) GetValues() []*Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FeatureID struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (x *FeatureID) Reset() <span class="cov0" title="0">{
        *x = FeatureID{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_serving_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureID) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureID) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureID) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_serving_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureID.ProtoReflect.Descriptor instead.
func (*FeatureID) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_serving_proto_rawDescGZIP(), []int{5}
}</span>

func (x *FeatureID) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureID) GetVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Version
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Entity struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *Entity) Reset() <span class="cov0" title="0">{
        *x = Entity{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_serving_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Entity) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Entity) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Entity) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_proto_serving_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Entity.ProtoReflect.Descriptor instead.
func (*Entity) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_serving_proto_rawDescGZIP(), []int{6}
}</span>

func (x *Entity) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Entity) GetValue() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type Value struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Types that are assignable to Value:
        //        *Value_StrValue
        //        *Value_IntValue
        //        *Value_FloatValue
        //        *Value_DoubleValue
        //        *Value_Int64Value
        Value isValue_Value `protobuf_oneof:"value"`
}

func (x *Value) Reset() <span class="cov0" title="0">{
        *x = Value{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_proto_serving_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Value) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Value) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Value) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_proto_serving_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use Value.ProtoReflect.Descriptor instead.
func (*Value) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_proto_serving_proto_rawDescGZIP(), []int{7}
}</span>

func (m *Value) GetValue() isValue_Value <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Value) GetStrValue() string <span class="cov0" title="0">{
        if x, ok := x.GetValue().(*Value_StrValue); ok </span><span class="cov0" title="0">{
                return x.StrValue
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Value) GetIntValue() int32 <span class="cov0" title="0">{
        if x, ok := x.GetValue().(*Value_IntValue); ok </span><span class="cov0" title="0">{
                return x.IntValue
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Value) GetFloatValue() float32 <span class="cov0" title="0">{
        if x, ok := x.GetValue().(*Value_FloatValue); ok </span><span class="cov0" title="0">{
                return x.FloatValue
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Value) GetDoubleValue() float64 <span class="cov0" title="0">{
        if x, ok := x.GetValue().(*Value_DoubleValue); ok </span><span class="cov0" title="0">{
                return x.DoubleValue
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Value) GetInt64Value() int64 <span class="cov0" title="0">{
        if x, ok := x.GetValue().(*Value_Int64Value); ok </span><span class="cov0" title="0">{
                return x.Int64Value
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type isValue_Value interface {
        isValue_Value()
}

type Value_StrValue struct {
        StrValue string `protobuf:"bytes,1,opt,name=str_value,json=strValue,proto3,oneof"`
}

type Value_IntValue struct {
        IntValue int32 `protobuf:"varint,2,opt,name=int_value,json=intValue,proto3,oneof"`
}

type Value_FloatValue struct {
        FloatValue float32 `protobuf:"fixed32,3,opt,name=float_value,json=floatValue,proto3,oneof"`
}

type Value_DoubleValue struct {
        DoubleValue float64 `protobuf:"fixed64,4,opt,name=double_value,json=doubleValue,proto3,oneof"`
}

type Value_Int64Value struct {
        Int64Value int64 `protobuf:"varint,5,opt,name=int64_value,json=int64Value,proto3,oneof"`
}

func (*Value_StrValue) isValue_Value() {<span class="cov0" title="0">}</span>

func (*Value_IntValue) isValue_Value() {<span class="cov0" title="0">}</span>

func (*Value_FloatValue) isValue_Value() {<span class="cov0" title="0">}</span>

func (*Value_DoubleValue) isValue_Value() {<span class="cov0" title="0">}</span>

func (*Value_Int64Value) isValue_Value() {<span class="cov0" title="0">}</span>

var File_proto_serving_proto protoreflect.FileDescriptor

var file_proto_serving_proto_rawDesc = []byte{
        0x0a, 0x13, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x19, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f,
        0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x22, 0x50, 0x0a, 0x13, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x44, 0x61, 0x74, 0x61,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x39, 0x0a, 0x02, 0x69, 0x64, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72,
        0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
        0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x44, 0x61, 0x74, 0x61, 0x49, 0x44, 0x52, 0x02,
        0x69, 0x64, 0x22, 0x3e, 0x0a, 0x0e, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x44, 0x61,
        0x74, 0x61, 0x49, 0x44, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73,
        0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69,
        0x6f, 0x6e, 0x22, 0x87, 0x01, 0x0a, 0x0f, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x44,
        0x61, 0x74, 0x61, 0x52, 0x6f, 0x77, 0x12, 0x3c, 0x0a, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x08, 0x66, 0x65, 0x61, 0x74,
        0x75, 0x72, 0x65, 0x73, 0x12, 0x36, 0x0a, 0x05, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72,
        0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
        0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x22, 0x96, 0x01, 0x0a,
        0x13, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x40, 0x0a, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73,
        0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x49, 0x44, 0x52, 0x08, 0x66, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x3d, 0x0a, 0x08, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x69,
        0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x08, 0x65, 0x6e, 0x74,
        0x69, 0x74, 0x69, 0x65, 0x73, 0x22, 0x46, 0x0a, 0x0a, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x52, 0x6f, 0x77, 0x12, 0x38, 0x0a, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x01, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f, 0x72,
        0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
        0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x06, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x22, 0x39, 0x0a,
        0x09, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x49, 0x44, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61,
        0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18,
        0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x32, 0x0a, 0x06, 0x45, 0x6e, 0x74, 0x69,
        0x74, 0x79, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0xb9, 0x01, 0x0a,
        0x05, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x1d, 0x0a, 0x09, 0x73, 0x74, 0x72, 0x5f, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52, 0x08, 0x73, 0x74, 0x72,
        0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x1d, 0x0a, 0x09, 0x69, 0x6e, 0x74, 0x5f, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52, 0x08, 0x69, 0x6e, 0x74, 0x56,
        0x61, 0x6c, 0x75, 0x65, 0x12, 0x21, 0x0a, 0x0b, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x5f, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x02, 0x48, 0x00, 0x52, 0x0a, 0x66, 0x6c, 0x6f,
        0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x23, 0x0a, 0x0c, 0x64, 0x6f, 0x75, 0x62, 0x6c,
        0x65, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x01, 0x48, 0x00, 0x52,
        0x0b, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x21, 0x0a, 0x0b,
        0x69, 0x6e, 0x74, 0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28,
        0x03, 0x48, 0x00, 0x52, 0x0a, 0x69, 0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x42,
        0x07, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x32, 0xe2, 0x01, 0x0a, 0x07, 0x46, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x12, 0x6e, 0x0a, 0x0c, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67,
        0x44, 0x61, 0x74, 0x61, 0x12, 0x2e, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f,
        0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x44, 0x61, 0x74, 0x61, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x2a, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f,
        0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x54, 0x72, 0x61, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x44, 0x61, 0x74, 0x61, 0x52, 0x6f, 0x77,
        0x22, 0x00, 0x30, 0x01, 0x12, 0x67, 0x0a, 0x0c, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53,
        0x65, 0x72, 0x76, 0x65, 0x12, 0x2e, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f,
        0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x25, 0x2e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x66, 0x6f,
        0x72, 0x6d, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x52, 0x6f, 0x77, 0x22, 0x00, 0x42, 0x26, 0x5a,
        0x24, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x74,
        0x75, 0x72, 0x65, 0x66, 0x6f, 0x72, 0x6d, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2f,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_proto_serving_proto_rawDescOnce sync.Once
        file_proto_serving_proto_rawDescData = file_proto_serving_proto_rawDesc
)

func file_proto_serving_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_proto_serving_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_proto_serving_proto_rawDescData = protoimpl.X.CompressGZIP(file_proto_serving_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_proto_serving_proto_rawDescData</span>
}

var file_proto_serving_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_proto_serving_proto_goTypes = []interface{}{
        (*TrainingDataRequest)(nil), // 0: featureform.serving.proto.TrainingDataRequest
        (*TrainingDataID)(nil),      // 1: featureform.serving.proto.TrainingDataID
        (*TrainingDataRow)(nil),     // 2: featureform.serving.proto.TrainingDataRow
        (*FeatureServeRequest)(nil), // 3: featureform.serving.proto.FeatureServeRequest
        (*FeatureRow)(nil),          // 4: featureform.serving.proto.FeatureRow
        (*FeatureID)(nil),           // 5: featureform.serving.proto.FeatureID
        (*Entity)(nil),              // 6: featureform.serving.proto.Entity
        (*Value)(nil),               // 7: featureform.serving.proto.Value
}
var file_proto_serving_proto_depIdxs = []int32{
        1, // 0: featureform.serving.proto.TrainingDataRequest.id:type_name -&gt; featureform.serving.proto.TrainingDataID
        7, // 1: featureform.serving.proto.TrainingDataRow.features:type_name -&gt; featureform.serving.proto.Value
        7, // 2: featureform.serving.proto.TrainingDataRow.label:type_name -&gt; featureform.serving.proto.Value
        5, // 3: featureform.serving.proto.FeatureServeRequest.features:type_name -&gt; featureform.serving.proto.FeatureID
        6, // 4: featureform.serving.proto.FeatureServeRequest.entities:type_name -&gt; featureform.serving.proto.Entity
        7, // 5: featureform.serving.proto.FeatureRow.values:type_name -&gt; featureform.serving.proto.Value
        0, // 6: featureform.serving.proto.Feature.TrainingData:input_type -&gt; featureform.serving.proto.TrainingDataRequest
        3, // 7: featureform.serving.proto.Feature.FeatureServe:input_type -&gt; featureform.serving.proto.FeatureServeRequest
        2, // 8: featureform.serving.proto.Feature.TrainingData:output_type -&gt; featureform.serving.proto.TrainingDataRow
        4, // 9: featureform.serving.proto.Feature.FeatureServe:output_type -&gt; featureform.serving.proto.FeatureRow
        8, // [8:10] is the sub-list for method output_type
        6, // [6:8] is the sub-list for method input_type
        6, // [6:6] is the sub-list for extension type_name
        6, // [6:6] is the sub-list for extension extendee
        0, // [0:6] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_proto_serving_proto_init() }</span>
func file_proto_serving_proto_init() <span class="cov8" title="1">{
        if File_proto_serving_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_proto_serving_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TrainingDataRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_serving_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TrainingDataID); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_serving_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TrainingDataRow); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_serving_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureServeRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_serving_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureRow); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_serving_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureID); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_serving_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Entity); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_proto_serving_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Value); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_proto_serving_proto_msgTypes[7].OneofWrappers = []interface{}{
                (*Value_StrValue)(nil),
                (*Value_IntValue)(nil),
                (*Value_FloatValue)(nil),
                (*Value_DoubleValue)(nil),
                (*Value_Int64Value)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_proto_serving_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   8,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_proto_serving_proto_goTypes,
                DependencyIndexes: file_proto_serving_proto_depIdxs,
                MessageInfos:      file_proto_serving_proto_msgTypes,
        }.Build()
        File_proto_serving_proto = out.File
        file_proto_serving_proto_rawDesc = nil
        file_proto_serving_proto_goTypes = nil
        file_proto_serving_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: proto/serving.proto

package proto

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// FeatureClient is the client API for Feature service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FeatureClient interface {
        TrainingData(ctx context.Context, in *TrainingDataRequest, opts ...grpc.CallOption) (Feature_TrainingDataClient, error)
        FeatureServe(ctx context.Context, in *FeatureServeRequest, opts ...grpc.CallOption) (*FeatureRow, error)
}

type featureClient struct {
        cc grpc.ClientConnInterface
}

func NewFeatureClient(cc grpc.ClientConnInterface) FeatureClient <span class="cov0" title="0">{
        return &amp;featureClient{cc}
}</span>

func (c *featureClient) TrainingData(ctx context.Context, in *TrainingDataRequest, opts ...grpc.CallOption) (Feature_TrainingDataClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;Feature_ServiceDesc.Streams[0], "/featureform.serving.proto.Feature/TrainingData", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;featureTrainingDataClient{stream}
        if err := x.ClientStream.SendMsg(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := x.ClientStream.CloseSend(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return x, nil</span>
}

type Feature_TrainingDataClient interface {
        Recv() (*TrainingDataRow, error)
        grpc.ClientStream
}

type featureTrainingDataClient struct {
        grpc.ClientStream
}

func (x *featureTrainingDataClient) Recv() (*TrainingDataRow, error) <span class="cov0" title="0">{
        m := new(TrainingDataRow)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

func (c *featureClient) FeatureServe(ctx context.Context, in *FeatureServeRequest, opts ...grpc.CallOption) (*FeatureRow, error) <span class="cov0" title="0">{
        out := new(FeatureRow)
        err := c.cc.Invoke(ctx, "/featureform.serving.proto.Feature/FeatureServe", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// FeatureServer is the server API for Feature service.
// All implementations must embed UnimplementedFeatureServer
// for forward compatibility
type FeatureServer interface {
        TrainingData(*TrainingDataRequest, Feature_TrainingDataServer) error
        FeatureServe(context.Context, *FeatureServeRequest) (*FeatureRow, error)
        mustEmbedUnimplementedFeatureServer()
}

// UnimplementedFeatureServer must be embedded to have forward compatible implementations.
type UnimplementedFeatureServer struct {
}

func (UnimplementedFeatureServer) TrainingData(*TrainingDataRequest, Feature_TrainingDataServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method TrainingData not implemented")
}</span>
func (UnimplementedFeatureServer) FeatureServe(context.Context, *FeatureServeRequest) (*FeatureRow, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method FeatureServe not implemented")
}</span>
func (UnimplementedFeatureServer) mustEmbedUnimplementedFeatureServer() {<span class="cov0" title="0">}</span>

// UnsafeFeatureServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FeatureServer will
// result in compilation errors.
type UnsafeFeatureServer interface {
        mustEmbedUnimplementedFeatureServer()
}

func RegisterFeatureServer(s grpc.ServiceRegistrar, srv FeatureServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;Feature_ServiceDesc, srv)
}</span>

func _Feature_TrainingData_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        m := new(TrainingDataRequest)
        if err := stream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.(FeatureServer).TrainingData(m, &amp;featureTrainingDataServer{stream})</span>
}

type Feature_TrainingDataServer interface {
        Send(*TrainingDataRow) error
        grpc.ServerStream
}

type featureTrainingDataServer struct {
        grpc.ServerStream
}

func (x *featureTrainingDataServer) Send(m *TrainingDataRow) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func _Feature_FeatureServe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(FeatureServeRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(FeatureServer).FeatureServe(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/featureform.serving.proto.Feature/FeatureServe",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(FeatureServer).FeatureServe(ctx, req.(*FeatureServeRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Feature_ServiceDesc is the grpc.ServiceDesc for Feature service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Feature_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "featureform.serving.proto.Feature",
        HandlerType: (*FeatureServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "FeatureServe",
                        Handler:    _Feature_FeatureServe_Handler,
                },
        },
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "TrainingData",
                        Handler:       _Feature_TrainingData_Handler,
                        ServerStreams: true,
                },
        },
        Metadata: "proto/serving.proto",
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package runner

import (
        "fmt"
        "sync"
)

type Runner interface {
        Run() (CompletionStatus, error)
}

type MaterializedChunkRunner struct {
        Materialized MaterializedFeatures
        Table        OnlineTable
        ChunkSize    int
        ChunkIdx     int
}

type CompletionStatus interface {
        Complete() bool
        String() string
        Wait() error
        Err() error
}

type MaterializedFeatures interface {
        NumRows() (int, error)
        IterateSegment(begin int, end int) (FeatureIterator, error)
}

type OnlineTable interface {
        Set(entity string, value interface{}) error
        Get(entity string) (interface{}, error)
}

type FeatureIterator interface {
        Next() bool
        Err() error
        Entity() string
        Value() interface{}
}

type ResultSync struct {
        err  error
        done bool
        mu   sync.RWMutex
}

func (m *MaterializedChunkRunner) Run() (CompletionStatus, error) <span class="cov8" title="1">{
        done := make(chan interface{})
        jobWatcher := &amp;CopyCompletionWatcher{
                ResultSync:  &amp;ResultSync{},
                DoneChannel: done,
        }
        go func() </span><span class="cov8" title="1">{
                if m.ChunkSize == 0 </span><span class="cov8" title="1">{
                        jobWatcher.EndWatch(nil)
                        return
                }</span>
                <span class="cov8" title="1">numRows, err := m.Materialized.NumRows()
                if err != nil </span><span class="cov8" title="1">{
                        jobWatcher.EndWatch(err)
                        return
                }</span>
                <span class="cov8" title="1">if numRows == 0 </span><span class="cov8" title="1">{
                        jobWatcher.EndWatch(nil)
                        return
                }</span>

                <span class="cov8" title="1">rowStart := m.ChunkIdx * m.ChunkSize
                rowEnd := rowStart + m.ChunkSize
                if rowEnd &gt; numRows </span><span class="cov8" title="1">{
                        rowEnd = numRows
                }</span>
                <span class="cov8" title="1">it, err := m.Materialized.IterateSegment(rowStart, rowEnd)
                if err != nil </span><span class="cov8" title="1">{
                        jobWatcher.EndWatch(err)
                        return
                }</span>
                <span class="cov8" title="1">for it.Next() </span><span class="cov8" title="1">{
                        value := it.Value()
                        entity := it.Entity()
                        err := m.Table.Set(entity, value)
                        if err != nil </span><span class="cov8" title="1">{
                                jobWatcher.EndWatch(err)
                                return
                        }</span>
                }
                <span class="cov8" title="1">if err = it.Err(); err != nil </span><span class="cov8" title="1">{
                        jobWatcher.EndWatch(err)
                        return
                }</span>
                <span class="cov8" title="1">jobWatcher.EndWatch(nil)</span>
        }()
        <span class="cov8" title="1">return jobWatcher, nil</span>
}

func (c *CopyCompletionWatcher) EndWatch(err error) <span class="cov8" title="1">{
        c.ResultSync.DoneWithError(err)
        close(c.DoneChannel)
}</span>

func (r *ResultSync) Done() bool <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.done
}</span>

func (r *ResultSync) Err() error <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        return r.err
}</span>

func (r *ResultSync) DoneWithError(err error) <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.err = err
        r.done = true
}</span>

type CopyCompletionWatcher struct {
        ResultSync  *ResultSync
        DoneChannel chan interface{}
}

func (m *CopyCompletionWatcher) Err() error <span class="cov8" title="1">{
        return m.ResultSync.Err()
}</span>

func (m *CopyCompletionWatcher) Wait() error <span class="cov8" title="1">{
        &lt;-m.DoneChannel
        return m.ResultSync.Err()
}</span>

func (m *CopyCompletionWatcher) Complete() bool <span class="cov8" title="1">{
        return m.ResultSync.Done()
}</span>

func (m *CopyCompletionWatcher) String() string <span class="cov8" title="1">{
        done := m.ResultSync.Done()
        err := m.ResultSync.Err()
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("Job failed with error: %v", err)
        }</span>
        <span class="cov8" title="1">if !done </span><span class="cov8" title="1">{
                return "Job still running."
        }</span>
        <span class="cov8" title="1">return "Job completed succesfully."</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package runner

import (
        "fmt"
)

type Config []byte

type RunnerFactory func(config Config) (Runner, error)

var factoryMap = make(map[string]RunnerFactory)

func RegisterFactory(name string, runnerFactory RunnerFactory) error <span class="cov8" title="1">{
        if _, exists := factoryMap[name]; exists </span><span class="cov8" title="1">{
                return fmt.Errorf("factory %s already registered", name)
        }</span>
        <span class="cov8" title="1">factoryMap[name] = runnerFactory
        return nil</span>
}

func Create(name string, config Config) (Runner, error) <span class="cov8" title="1">{
        factory, exists := factoryMap[name]
        if !exists </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("factory %s does not exist", name)
        }</span>
        <span class="cov8" title="1">runner, err := factory(config)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return runner, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package main

import (
        "context"
        "fmt"
        "net"

        "github.com/featureform/serving/dataset"
        metrics "github.com/featureform/serving/metrics"

        pb "github.com/featureform/serving/proto"
        "go.uber.org/zap"
        "google.golang.org/grpc"
)

type FeatureServer struct {
        pb.UnimplementedFeatureServer
        Metrics          metrics.MetricsHandler
        DatasetProviders map[string]dataset.OfflineProvider
        FeatureProviders map[string]dataset.OnlineProvider
        Metadata         MetadataProvider
        Logger           *zap.SugaredLogger
}

func NewFeatureServer(promMetrics metrics.MetricsHandler, logger *zap.SugaredLogger) (*FeatureServer, error) <span class="cov0" title="0">{
        logger.Debug("Creating new training data server")
        // Manually setup metadata and providers, this will be done by user-provided config files later.
        csvStorageId := "localCSV"
        csvProvider := &amp;LocalCSVProvider{logger}
        metadata, err := NewLocalMemoryMetadata(logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to create metadata client", "Error", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">trainMetaErr := metadata.SetTrainingSetMetadata("f1", "v1", TrainingSetEntry{
                StorageId: csvStorageId,
                Key: csvProvider.ToKey("testdata/house_price.csv", CSVSchema{
                        HasHeader: true,
                        Features:  []string{"zip"},
                        Label:     "price",
                        Types: map[string]dataset.Type{
                                "zip":   dataset.String,
                                "price": dataset.Int,
                        },
                }),
        })
        if trainMetaErr != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to set training set metadata", "Error", trainMetaErr)
                return nil, trainMetaErr
        }</span>

        <span class="cov0" title="0">onlineStorageId := "online-memory"
        onlineProvider := NewMemoryOnlineProvider()
        key := onlineProvider.ToKey("f1", "v1")
        onlineProvider.SetFeature("f1", "v1", "a", 12.34)
        featureMetaErr := metadata.SetFeatureMetadata("f1", "v1", FeatureEntry{
                StorageId: onlineStorageId,
                Entity:    "user",
                Key:       key,
        })
        if featureMetaErr != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to set feature metadata", "Error", trainMetaErr)
                return nil, trainMetaErr
        }</span>
        <span class="cov0" title="0">return &amp;FeatureServer{
                Metrics: promMetrics,
                DatasetProviders: map[string]dataset.OfflineProvider{
                        csvStorageId: csvProvider,
                },
                FeatureProviders: map[string]dataset.OnlineProvider{
                        onlineStorageId: onlineProvider,
                },
                Metadata: metadata,
                Logger:   logger,
        }, nil</span>
}

func (serv *FeatureServer) TrainingData(req *pb.TrainingDataRequest, stream pb.Feature_TrainingDataServer) error <span class="cov0" title="0">{
        id := req.GetId()
        name, version := id.GetName(), id.GetVersion()
        featureObserver := serv.Metrics.BeginObservingTrainingServe(name, version)
        defer featureObserver.Finish()
        logger := serv.Logger.With("Name", name, "Version", version)
        logger.Info("Serving training data")
        entry, err := serv.Metadata.TrainingSetMetadata(name, version)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Metadata lookup failed", "Err", err)
                featureObserver.SetError()
                return err
        }</span>
        <span class="cov0" title="0">logger = logger.With("Entry", entry)
        provider, has := serv.DatasetProviders[entry.StorageId]
        if !has </span><span class="cov0" title="0">{
                logger.Error("Provider not loaded on server")
                featureObserver.SetError()
                return fmt.Errorf("Unknown provider: %s", entry.StorageId)
        }</span>
        <span class="cov0" title="0">dataset, err := provider.GetDatasetReader(entry.Key)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to get dataset reader", "Error", err)
                featureObserver.SetError()
                return err
        }</span>
        <span class="cov0" title="0">for dataset.Scan() </span><span class="cov0" title="0">{
                if err := stream.Send(dataset.Row().Serialized()); err != nil </span><span class="cov0" title="0">{
                        logger.Errorw("Failed to write to stream", "Error", err)
                        featureObserver.SetError()
                        return err
                }</span>
                <span class="cov0" title="0">featureObserver.ServeRow()</span>
        }
        <span class="cov0" title="0">if err := dataset.Err(); err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Dataset error", "Error", err)
                featureObserver.SetError()
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (serv *FeatureServer) FeatureServe(ctx context.Context, req *pb.FeatureServeRequest) (*pb.FeatureRow, error) <span class="cov0" title="0">{
        features := req.GetFeatures()
        vals := make([]*pb.Value, len(features))
        entities := make(map[string]string)
        for _, entity := range req.GetEntities() </span><span class="cov0" title="0">{
                entities[entity.GetName()] = entity.GetValue()
        }</span>
        <span class="cov0" title="0">for i, feature := range req.GetFeatures() </span><span class="cov0" title="0">{
                name, version := feature.GetName(), feature.GetVersion()
                serv.Logger.Infow("Serving feature", "Name", name, "Version", version, "Entities", entities)
                val, err := serv.getFeatureValue(name, version, entities)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">vals[i] = val</span>
        }
        <span class="cov0" title="0">return &amp;pb.FeatureRow{
                Values: vals,
        }, nil</span>
}

func (serv *FeatureServer) getFeatureValue(name, version string, entities map[string]string) (*pb.Value, error) <span class="cov0" title="0">{
        obs := serv.Metrics.BeginObservingOnlineServe(name, version)
        defer obs.Finish()
        logger := serv.Logger.With("Name", name, "Version", version, "Entities", entities)
        logger.Debug("Getting metadata")
        entry, err := serv.Metadata.FeatureMetadata(name, version)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Metadata lookup failed", "Err", err)
                obs.SetError()
                return nil, err
        }</span>
        <span class="cov0" title="0">logger = logger.With("Entry", entry)
        entity, has := entities[entry.Entity]
        if !has </span><span class="cov0" title="0">{
                logger.Errorw("Entity not found", "Entity Name", entry.Entity)
                obs.SetError()
                return nil, fmt.Errorf("Entity not found: %s", entry.Entity)
        }</span>

        <span class="cov0" title="0">provider, has := serv.FeatureProviders[entry.StorageId]
        if !has </span><span class="cov0" title="0">{
                logger.Error("Provider not loaded on server")
                obs.SetError()
                return nil, fmt.Errorf("Unknown provider: %s", entry.StorageId)
        }</span>

        <span class="cov0" title="0">lookup, err := provider.GetFeatureLookup(entry.Key)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Failed to get feature lookup", "Error", err)
                obs.SetError()
                return nil, err
        }</span>

        <span class="cov0" title="0">val, err := lookup.Get(entity)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorw("Entity not found", "Error", err)
                obs.SetError()
                return nil, err
        }</span>
        <span class="cov0" title="0">obs.ServeRow()
        return val.Serialized(), nil</span>
}

func main() <span class="cov0" title="0">{
        logger := zap.NewExample().Sugar()
        promMetrics := metrics.NewMetrics("test")
        port := ":8080"
        metrics_port := ":2112"
        lis, err := net.Listen("tcp", port)
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicw("Failed to listen on port", "Err", err)
        }</span>
        <span class="cov0" title="0">grpcServer := grpc.NewServer()
        serv, err := NewFeatureServer(promMetrics, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Panicw("Failed to create training server", "Err", err)
        }</span>
        <span class="cov0" title="0">pb.RegisterFeatureServer(grpcServer, serv)
        logger.Infow("Serving metrics", "Port", metrics_port)
        go promMetrics.ExposePort(metrics_port)
        logger.Infow("Server starting", "Port", port)
        serveErr := grpcServer.Serve(lis)
        if serveErr != nil </span><span class="cov0" title="0">{
                logger.Errorw("Serve failed with error", "Err", serveErr)
        }</span>

}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
